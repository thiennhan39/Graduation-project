CCS PCM C Compiler, Version 5.101, 43599               20-May-23 16:09

               Filename:   D:\DATN\filezip\PIC C compiler\Cuadatinhnang\main.lst

               ROM used:   3605 words (44%)
                           Largest free fragment is 2048
               RAM used:   91 (25%) at main() level
                           130 (35%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   1A4
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.0
0030:  GOTO   033
0031:  BTFSC  0C.0
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   07C
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   05A
.................... #include <main.h>
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
*
0065:  BSF    03.5
0066:  MOVF   40,W
0067:  CLRF   78
0068:  SUBWF  3F,W
0069:  BTFSC  03.0
006A:  GOTO   06E
006B:  MOVF   3F,W
006C:  MOVWF  77
006D:  GOTO   07A
006E:  CLRF   77
006F:  MOVLW  08
0070:  MOVWF  41
0071:  RLF    3F,F
0072:  RLF    77,F
0073:  MOVF   40,W
0074:  SUBWF  77,W
0075:  BTFSC  03.0
0076:  MOVWF  77
0077:  RLF    78,F
0078:  DECFSZ 41,F
0079:  GOTO   071
007A:  BCF    03.5
007B:  RETURN
*
009F:  DATA D0,20
00A0:  DATA D3,29
00A1:  DATA 3A,00
00A2:  DATA 57,29
00A3:  DATA 4F,27
00A4:  DATA 47,10
00A5:  DATA D0,20
00A6:  DATA D3,29
00A7:  DATA D7,27
00A8:  DATA 52,22
00A9:  DATA 00,00
00AA:  DATA 43,26
00AB:  DATA CF,29
00AC:  DATA 45,00
00AD:  DATA C2,22
00AE:  DATA 4C,26
00AF:  DATA 00,01
00B0:  DATA 43,24
00B1:  DATA D5,27
00B2:  DATA CE,23
00B3:  DATA 00,01
00B4:  DATA 0C,10
00B5:  DATA 74,34
00B6:  DATA 65,10
00B7:  DATA E8,37
00B8:  DATA 70,10
00B9:  DATA EC,32
00BA:  DATA 00,01
00BB:  DATA F8,34
00BC:  DATA 6E,10
00BD:  DATA ED,37
00BE:  DATA 69,10
00BF:  DATA F6,30
00C0:  DATA 6F,00
00C1:  DATA D3,20
00C2:  DATA 49,10
00C3:  DATA 54,24
00C4:  DATA 45,00
00C5:  DATA D7,20
00C6:  DATA 52,27
00C7:  DATA 49,27
00C8:  DATA C7,10
00C9:  DATA A1,10
00CA:  DATA 00,01
00CB:  DATA 0C,00
00CC:  DATA 4F,28
00CD:  DATA 45,27
00CE:  DATA 00,01
00CF:  DATA 32,17
00D0:  DATA A0,25
00D1:  DATA C8,27
00D2:  DATA 41,10
00D3:  DATA 20,10
00D4:  DATA 33,17
00D5:  DATA 52,23
00D6:  DATA 49,22
00D7:  DATA 00,01
00D8:  DATA C3,2A
00D9:  DATA 41,10
00DA:  DATA C4,20
00DB:  DATA CE,23
00DC:  DATA A0,26
00DD:  DATA 4F,00
00DE:  DATA 4E,34
00DF:  DATA 61,38
00E0:  DATA A0,36
00E1:  DATA 61,3A
00E2:  DATA A0,35
00E3:  DATA E8,30
00E4:  DATA 75,00
00E5:  DATA 50,39
00E6:  DATA E5,39
00E7:  DATA 73,10
00E8:  DATA 31,10
00E9:  DATA F4,37
00EA:  DATA 20,31
00EB:  DATA EC,37
00EC:  DATA E3,35
00ED:  DATA 00,01
00EE:  DATA 8C,18
00EF:  DATA 2E,10
00F0:  DATA 54,34
00F1:  DATA E5,36
00F2:  DATA 20,3A
00F3:  DATA E8,32
00F4:  DATA 00,01
00F5:  DATA 32,17
00F6:  DATA 20,2C
00F7:  DATA EF,30
00F8:  DATA 20,3A
00F9:  DATA E8,32
00FA:  DATA 00,01
00FB:  DATA 0C,10
00FC:  DATA D1,3A
00FD:  DATA 65,3A
00FE:  DATA 20,3A
00FF:  DATA E8,32
0100:  DATA A0,36
0101:  DATA EF,34
0102:  DATA 00,01
0103:  DATA 0C,10
0104:  DATA 54,34
0105:  DATA 65,10
0106:  DATA E4,30
0107:  DATA 20,3A
0108:  DATA E8,32
0109:  DATA 6D,00
010A:  DATA 0C,10
010B:  DATA D8,27
010C:  DATA CE,23
010D:  DATA 00,01
010E:  DATA 0C,10
010F:  DATA D1,3A
0110:  DATA 65,3A
0111:  DATA 20,3A
0112:  DATA E8,32
0113:  DATA A0,31
0114:  DATA 61,37
0115:  DATA 20,3C
0116:  DATA EF,30
0117:  DATA 00,01
0118:  DATA 0C,10
0119:  DATA C4,30
011A:  DATA 20,3C
011B:  DATA EF,30
011C:  DATA 00,01
011D:  DATA 8C,25
011E:  DATA E8,37
011F:  DATA EE,33
0120:  DATA A0,31
0121:  DATA 6F,10
0122:  DATA 74,34
0123:  DATA 65,10
0124:  DATA EE,30
0125:  DATA 79,00
0126:  DATA 50,39
0127:  DATA E5,39
0128:  DATA 73,10
0129:  DATA 31,10
012A:  DATA F4,37
012B:  DATA 20,31
012C:  DATA EC,37
012D:  DATA E3,35
012E:  DATA 00,00
*
03A5:  MOVF   0B,W
03A6:  MOVWF  7B
03A7:  BCF    0B.7
03A8:  BSF    03.5
03A9:  BSF    03.6
03AA:  BSF    0C.7
03AB:  BSF    0C.0
03AC:  NOP
03AD:  NOP
03AE:  BTFSS  7B.7
03AF:  GOTO   3B5
03B0:  BCF    03.5
03B1:  BCF    03.6
03B2:  BSF    0B.7
03B3:  BSF    03.5
03B4:  BSF    03.6
03B5:  BCF    03.5
03B6:  MOVF   0C,W
03B7:  ANDLW  7F
03B8:  BTFSC  03.2
03B9:  GOTO   3F5
03BA:  MOVWF  7B
03BB:  MOVF   0D,W
03BC:  MOVWF  7C
03BD:  MOVF   0F,W
03BE:  MOVWF  7D
03BF:  MOVF   7B,W
03C0:  BCF    03.6
03C1:  BTFSS  0C.4
03C2:  GOTO   3C1
03C3:  MOVWF  19
03C4:  MOVF   7C,W
03C5:  BSF    03.6
03C6:  MOVWF  0D
03C7:  MOVF   7D,W
03C8:  MOVWF  0F
03C9:  BCF    03.6
03CA:  MOVF   0B,W
03CB:  MOVWF  7E
03CC:  BCF    0B.7
03CD:  BSF    03.5
03CE:  BSF    03.6
03CF:  BSF    0C.7
03D0:  BSF    0C.0
03D1:  NOP
03D2:  NOP
03D3:  BTFSS  7E.7
03D4:  GOTO   3DA
03D5:  BCF    03.5
03D6:  BCF    03.6
03D7:  BSF    0B.7
03D8:  BSF    03.5
03D9:  BSF    03.6
03DA:  BCF    03.5
03DB:  RLF    0C,W
03DC:  RLF    0E,W
03DD:  ANDLW  7F
03DE:  BTFSC  03.2
03DF:  GOTO   3F5
03E0:  MOVWF  7B
03E1:  MOVF   0D,W
03E2:  MOVWF  7C
03E3:  MOVF   0F,W
03E4:  MOVWF  7D
03E5:  MOVF   7B,W
03E6:  BCF    03.6
03E7:  BTFSS  0C.4
03E8:  GOTO   3E7
03E9:  MOVWF  19
03EA:  MOVF   7C,W
03EB:  BSF    03.6
03EC:  MOVWF  0D
03ED:  MOVF   7D,W
03EE:  MOVWF  0F
03EF:  INCF   0D,F
03F0:  BTFSC  03.2
03F1:  INCF   0F,F
03F2:  BCF    03.6
03F3:  GOTO   3A5
03F4:  BSF    03.6
03F5:  BCF    03.6
03F6:  RETURN
*
056A:  MOVF   0B,W
056B:  BSF    03.5
056C:  MOVWF  20
056D:  BCF    03.5
056E:  BCF    0B.7
056F:  BSF    03.5
0570:  BSF    03.6
0571:  BSF    0C.7
0572:  BSF    0C.0
0573:  NOP
0574:  NOP
0575:  BCF    03.6
0576:  BTFSS  20.7
0577:  GOTO   57B
0578:  BCF    03.5
0579:  BSF    0B.7
057A:  BSF    03.5
057B:  BCF    03.5
057C:  BSF    03.6
057D:  MOVF   0C,W
057E:  ANDLW  7F
057F:  BTFSC  03.2
0580:  GOTO   5DC
0581:  BSF    03.5
0582:  BCF    03.6
0583:  MOVWF  20
0584:  BCF    03.5
0585:  BSF    03.6
0586:  MOVF   0D,W
0587:  BSF    03.5
0588:  BCF    03.6
0589:  MOVWF  21
058A:  BCF    03.5
058B:  BSF    03.6
058C:  MOVF   0F,W
058D:  BSF    03.5
058E:  BCF    03.6
058F:  MOVWF  22
0590:  MOVF   20,W
0591:  MOVWF  23
0592:  BCF    03.5
0593:  CALL   36B
0594:  BSF    03.5
0595:  MOVF   21,W
0596:  BCF    03.5
0597:  BSF    03.6
0598:  MOVWF  0D
0599:  BSF    03.5
059A:  BCF    03.6
059B:  MOVF   22,W
059C:  BCF    03.5
059D:  BSF    03.6
059E:  MOVWF  0F
059F:  BCF    03.6
05A0:  MOVF   0B,W
05A1:  BSF    03.5
05A2:  MOVWF  23
05A3:  BCF    03.5
05A4:  BCF    0B.7
05A5:  BSF    03.5
05A6:  BSF    03.6
05A7:  BSF    0C.7
05A8:  BSF    0C.0
05A9:  NOP
05AA:  NOP
05AB:  BCF    03.6
05AC:  BTFSS  23.7
05AD:  GOTO   5B1
05AE:  BCF    03.5
05AF:  BSF    0B.7
05B0:  BSF    03.5
05B1:  BCF    03.5
05B2:  BSF    03.6
05B3:  RLF    0C,W
05B4:  RLF    0E,W
05B5:  ANDLW  7F
05B6:  BTFSC  03.2
05B7:  GOTO   5DC
05B8:  BSF    03.5
05B9:  BCF    03.6
05BA:  MOVWF  20
05BB:  BCF    03.5
05BC:  BSF    03.6
05BD:  MOVF   0D,W
05BE:  BSF    03.5
05BF:  BCF    03.6
05C0:  MOVWF  21
05C1:  BCF    03.5
05C2:  BSF    03.6
05C3:  MOVF   0F,W
05C4:  BSF    03.5
05C5:  BCF    03.6
05C6:  MOVWF  22
05C7:  MOVF   20,W
05C8:  MOVWF  23
05C9:  BCF    03.5
05CA:  CALL   36B
05CB:  BSF    03.5
05CC:  MOVF   21,W
05CD:  BCF    03.5
05CE:  BSF    03.6
05CF:  MOVWF  0D
05D0:  BSF    03.5
05D1:  BCF    03.6
05D2:  MOVF   22,W
05D3:  BCF    03.5
05D4:  BSF    03.6
05D5:  MOVWF  0F
05D6:  INCF   0D,F
05D7:  BTFSC  03.2
05D8:  INCF   0F,F
05D9:  BCF    03.6
05DA:  GOTO   56A
05DB:  BSF    03.6
05DC:  BCF    03.6
05DD:  RETURN
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #use delay(crystal=20000000)
*
0292:  MOVLW  A4
0293:  MOVWF  04
0294:  BCF    03.7
0295:  MOVF   00,W
0296:  BTFSC  03.2
0297:  GOTO   2A5
0298:  MOVLW  06
0299:  MOVWF  78
029A:  CLRF   77
029B:  DECFSZ 77,F
029C:  GOTO   29B
029D:  DECFSZ 78,F
029E:  GOTO   29A
029F:  MOVLW  7B
02A0:  MOVWF  77
02A1:  DECFSZ 77,F
02A2:  GOTO   2A1
02A3:  DECFSZ 00,F
02A4:  GOTO   298
02A5:  RETURN
.................... 
.................... #define ROW1  PIN_B0
.................... #define ROW2  PIN_B1
.................... #define ROW3  PIN_B2
.................... #define ROW4  PIN_B3
.................... #define COL1  PIN_B4
.................... #define COL2  PIN_B5
.................... #define COL3  PIN_B6
.................... #define COL4  PIN_B7
.................... 
.................... 
.................... #define MFRC522_CS  PIN_C1                
.................... #define MFRC522_SCK PIN_C2
.................... #define MFRC522_SI  PIN_C3                           
.................... #define MFRC522_SO  PIN_C4             
.................... #define MFRC522_RST PIN_C5   
.................... 
.................... #include <lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
....................    output_float(LCD_DATA5);
....................    output_float(LCD_DATA6);
....................    output_float(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0xF;
*
02C3:  MOVLW  0F
02C4:  BSF    03.5
02C5:  ANDWF  08,W
02C6:  IORLW  F0
02C7:  MOVWF  08
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
02C8:  BCF    03.5
02C9:  BSF    08.2
....................    delay_cycles(1);
02CA:  NOP
....................    lcd_output_enable(1);
02CB:  BSF    08.0
....................    delay_cycles(1);
02CC:  NOP
....................    high = lcd_read_nibble();
02CD:  CALL   2B7
02CE:  MOVF   78,W
02CF:  BSF    03.5
02D0:  MOVWF  2B
....................       
....................    lcd_output_enable(0);
02D1:  BCF    03.5
02D2:  BCF    08.0
....................    delay_cycles(1);
02D3:  NOP
....................    lcd_output_enable(1);
02D4:  BSF    08.0
....................    delay_us(1);
02D5:  GOTO   2D6
02D6:  GOTO   2D7
02D7:  NOP
....................    low = lcd_read_nibble();
02D8:  CALL   2B7
02D9:  MOVF   78,W
02DA:  BSF    03.5
02DB:  MOVWF  2A
....................       
....................    lcd_output_enable(0);
02DC:  BCF    03.5
02DD:  BCF    08.0
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
02DE:  MOVLW  0F
02DF:  BSF    03.5
02E0:  ANDWF  08,W
02E1:  MOVWF  08
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
02E2:  SWAPF  2B,W
02E3:  MOVWF  77
02E4:  MOVLW  F0
02E5:  ANDWF  77,F
02E6:  MOVF   77,W
02E7:  IORWF  2A,W
02E8:  MOVWF  78
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
....................    n |= input(LCD_DATA5) << 1;
....................    n |= input(LCD_DATA6) << 2;
....................    n |= input(LCD_DATA7) << 3;
....................    
....................    return(n);
....................   #else
....................    return(lcd.data);
*
02B7:  MOVF   08,W
02B8:  MOVWF  77
02B9:  SWAPF  08,W
02BA:  ANDLW  0F
02BB:  MOVWF  78
....................   #endif
02BC:  RETURN
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
....................    output_bit(LCD_DATA5, bit_test(n, 1));
....................    output_bit(LCD_DATA6, bit_test(n, 2));
....................    output_bit(LCD_DATA7, bit_test(n, 3));
....................   #else      
....................    lcdlat.data = n;
*
02A6:  BSF    03.5
02A7:  SWAPF  2B,W
02A8:  ANDLW  F0
02A9:  MOVWF  77
02AA:  MOVLW  0F
02AB:  BCF    03.5
02AC:  ANDWF  08,W
02AD:  IORWF  77,W
02AE:  MOVWF  08
....................   #endif
....................       
....................    delay_cycles(1);
02AF:  NOP
....................    lcd_output_enable(1);
02B0:  BSF    08.0
....................    delay_us(2);
02B1:  MOVLW  03
02B2:  MOVWF  77
02B3:  DECFSZ 77,F
02B4:  GOTO   2B3
....................    lcd_output_enable(0);
02B5:  BCF    08.0
02B6:  RETURN
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
02BD:  BSF    03.5
02BE:  BCF    08.0
....................    lcd_rs_tris();
02BF:  BCF    08.1
....................    lcd_rw_tris();
02C0:  BCF    08.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
02C1:  BCF    03.5
02C2:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ;
*
02E9:  MOVF   78,W
02EA:  MOVWF  2A
02EB:  BTFSS  2A.7
02EC:  GOTO   2EF
02ED:  BCF    03.5
02EE:  GOTO   2C3
....................    lcd_output_rs(address);
02EF:  BTFSC  28.0
02F0:  GOTO   2F4
02F1:  BCF    03.5
02F2:  BCF    08.1
02F3:  BSF    03.5
02F4:  BTFSS  28.0
02F5:  GOTO   2F9
02F6:  BCF    03.5
02F7:  BSF    08.1
02F8:  BSF    03.5
....................    delay_cycles(1);
02F9:  NOP
....................    lcd_output_rw(0);
02FA:  BCF    03.5
02FB:  BCF    08.2
....................    delay_cycles(1);
02FC:  NOP
....................    lcd_output_enable(0);
02FD:  BCF    08.0
....................    lcd_send_nibble(n >> 4);
02FE:  BSF    03.5
02FF:  SWAPF  29,W
0300:  MOVWF  2A
0301:  MOVLW  0F
0302:  ANDWF  2A,F
0303:  MOVF   2A,W
0304:  MOVWF  2B
0305:  BCF    03.5
0306:  CALL   2A6
....................    lcd_send_nibble(n & 0xf);
0307:  BSF    03.5
0308:  MOVF   29,W
0309:  ANDLW  0F
030A:  MOVWF  2A
030B:  MOVWF  2B
030C:  BCF    03.5
030D:  CALL   2A6
030E:  RETURN
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
030F:  MOVLW  28
0310:  MOVWF  7B
0311:  MOVLW  0C
0312:  MOVWF  7C
0313:  MOVLW  01
0314:  MOVWF  7D
0315:  MOVLW  06
0316:  MOVWF  7E
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
0317:  BCF    08.0
....................    lcd_output_rs(0);
0318:  BCF    08.1
....................    lcd_output_rw(0);
0319:  BCF    08.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
031A:  MOVLW  0F
031B:  BSF    03.5
031C:  ANDWF  08,W
031D:  MOVWF  08
....................   #endif
....................    lcd_enable_tris();
031E:  BCF    08.0
....................    lcd_rs_tris();
031F:  BCF    08.1
....................    lcd_rw_tris();
0320:  BCF    08.2
....................  #endif
....................     
....................    delay_ms(15);
0321:  MOVLW  0F
0322:  MOVWF  24
0323:  BCF    03.5
0324:  CALL   292
....................    for(i=1;i<=3;++i)
0325:  MOVLW  01
0326:  MOVWF  74
0327:  MOVF   74,W
0328:  SUBLW  03
0329:  BTFSS  03.0
032A:  GOTO   337
....................    {
....................        lcd_send_nibble(3);
032B:  MOVLW  03
032C:  BSF    03.5
032D:  MOVWF  2B
032E:  BCF    03.5
032F:  CALL   2A6
....................        delay_ms(5);
0330:  MOVLW  05
0331:  BSF    03.5
0332:  MOVWF  24
0333:  BCF    03.5
0334:  CALL   292
0335:  INCF   74,F
0336:  GOTO   327
....................    }
....................    
....................    lcd_send_nibble(2);
0337:  MOVLW  02
0338:  BSF    03.5
0339:  MOVWF  2B
033A:  BCF    03.5
033B:  CALL   2A6
....................    delay_ms(5);
033C:  MOVLW  05
033D:  BSF    03.5
033E:  MOVWF  24
033F:  BCF    03.5
0340:  CALL   292
....................    for(i=0;i<=3;++i)
0341:  CLRF   74
0342:  MOVF   74,W
0343:  SUBLW  03
0344:  BTFSS  03.0
0345:  GOTO   354
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
0346:  MOVLW  7B
0347:  ADDWF  74,W
0348:  MOVWF  04
0349:  BCF    03.7
034A:  MOVF   00,W
034B:  MOVWF  75
034C:  BSF    03.5
034D:  CLRF   28
034E:  MOVF   75,W
034F:  MOVWF  29
0350:  BCF    03.5
0351:  CALL   2BD
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0352:  INCF   74,F
0353:  GOTO   342
0354:  BSF    0A.3
0355:  BCF    0A.4
0356:  GOTO   1D4 (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
0357:  BSF    03.5
0358:  DECFSZ 25,W
0359:  GOTO   35B
035A:  GOTO   35E
....................       address=LCD_LINE_TWO;
035B:  MOVLW  40
035C:  MOVWF  26
035D:  GOTO   35F
....................    else
....................       address=0;
035E:  CLRF   26
....................      
....................    address+=x-1;
035F:  MOVLW  01
0360:  SUBWF  24,W
0361:  ADDWF  26,F
....................    lcd_send_byte(0,0x80|address);
0362:  MOVF   26,W
0363:  IORLW  80
0364:  MOVWF  27
0365:  CLRF   28
0366:  MOVF   27,W
0367:  MOVWF  29
0368:  BCF    03.5
0369:  CALL   2BD
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
036A:  RETURN
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
036B:  BSF    03.5
036C:  MOVF   23,W
036D:  XORLW  07
036E:  BCF    03.5
036F:  BTFSC  03.2
0370:  GOTO   37B
0371:  XORLW  0B
0372:  BTFSC  03.2
0373:  GOTO   382
0374:  XORLW  06
0375:  BTFSC  03.2
0376:  GOTO   38E
0377:  XORLW  02
0378:  BTFSC  03.2
0379:  GOTO   396
037A:  GOTO   39D
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
037B:  MOVLW  01
037C:  BSF    03.5
037D:  MOVWF  24
037E:  MOVWF  25
037F:  BCF    03.5
0380:  CALL   357
0381:  GOTO   3A4
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
0382:  BSF    03.5
0383:  CLRF   28
0384:  MOVLW  01
0385:  MOVWF  29
0386:  BCF    03.5
0387:  CALL   2BD
....................                      delay_ms(2);
0388:  MOVLW  02
0389:  BSF    03.5
038A:  MOVWF  24
038B:  BCF    03.5
038C:  CALL   292
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
038D:  GOTO   3A4
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
038E:  MOVLW  01
038F:  BSF    03.5
0390:  MOVWF  24
0391:  MOVLW  02
0392:  MOVWF  25
0393:  BCF    03.5
0394:  CALL   357
0395:  GOTO   3A4
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
0396:  BSF    03.5
0397:  CLRF   28
0398:  MOVLW  10
0399:  MOVWF  29
039A:  BCF    03.5
039B:  CALL   2BD
039C:  GOTO   3A4
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
039D:  MOVLW  01
039E:  BSF    03.5
039F:  MOVWF  28
03A0:  MOVF   23,W
03A1:  MOVWF  29
03A2:  BCF    03.5
03A3:  CALL   2BD
....................      #endif
....................    }
03A4:  RETURN
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <Built_in.h>
.................... //#use spi(FORCE_HW,master,baud = 10000000, BITS=8,MSB_FIRST, stream = RFID, ENABLE_ACTIVE=0)// uses hardware SPI and gives this stream the name SPI_STREAM
.................... //MF522 Command word
.................... #define PCD_IDLE              0x00               //NO action; Cancel the current command
.................... #define PCD_AUTHENT           0x0E               //Authentication Key
.................... #define PCD_RECEIVE           0x08               //Receive Data
.................... #define PCD_TRANSMIT          0x04               //Transmit data
.................... #define PCD_TRANSCEIVE        0x0C               //Transmit and receive data,
.................... #define PCD_RESETPHASE        0x0F               //Reset
.................... #define PCD_CALCCRC           0x03               //CRC Calculate
.................... // Mifare_One card command word                 
.................... #define PICC_REQIDL          0x26               // find the antenna area does not enter hibernation
.................... #define PICC_REQALL          0x52               // find all the cards antenna area
.................... #define PICC_ANTICOLL        0x93               // anti-collision
.................... #define PICC_SElECTTAG       0x93               // election card
.................... #define PICC_AUTHENT1A       0x60               // authentication key A
.................... #define PICC_AUTHENT1B       0x61               // authentication key B
.................... #define PICC_READ            0x30               // Read Block
.................... #define PICC_WRITE           0xA0               // write block
.................... #define PICC_DECREMENT       0xC0               // debit
.................... #define PICC_INCREMENT       0xC1               // recharge
.................... #define PICC_RESTORE         0xC2               // transfer block data to the buffer
.................... #define PICC_TRANSFER        0xB0               // save the data in the buffer
.................... #define PICC_HALT            0x50               // Sleep
.................... //And MF522 The error code is returned when communication
.................... #define MI_OK                 0
.................... #define MI_NOTAGERR           1
.................... #define MI_ERR                2
.................... //------------------MFRC522 Register---------------
.................... //Page 0:Command and Status
.................... #define     RESERVED00            0x00    
.................... #define     COMMANDREG            0x01    
.................... #define     COMMIENREG            0x02    
.................... #define     DIVLENREG             0x03    
.................... #define     COMMIRQREG            0x04    
.................... #define     DIVIRQREG             0x05
.................... #define     ERRORREG              0x06    
.................... #define     STATUS1REG            0x07    
.................... #define     STATUS2REG            0x08    
.................... #define     FIFODATAREG           0x09
.................... #define     FIFOLEVELREG          0x0A
.................... #define     WATERLEVELREG         0x0B
.................... #define     CONTROLREG            0x0C
.................... #define     BITFRAMINGREG         0x0D
.................... #define     COLLREG               0x0E
.................... #define     RESERVED01            0x0F
.................... //PAGE 1:Command     
.................... #define     RESERVED10            0x10
.................... #define     MODEREG               0x11
.................... #define     TXMODEREG             0x12
.................... #define     RXMODEREG             0x13
.................... #define     TXCONTROLREG          0x14
.................... #define     TXAUTOREG             0x15
.................... #define     TXSELREG              0x16
.................... #define     RXSELREG              0x17
.................... #define     RXTHRESHOLDREG        0x18
.................... #define     DEMODREG              0x19
.................... #define     RESERVED11            0x1A
.................... #define     RESERVED12            0x1B
.................... #define     MIFAREREG             0x1C
.................... #define     RESERVED13            0x1D
.................... #define     RESERVED14            0x1E
.................... #define     SERIALSPEEDREG        0x1F
.................... //PAGE 2:CFG    
.................... #define     RESERVED20            0x20  
.................... #define     CRCRESULTREGM         0x21
.................... #define     CRCRESULTREGL         0x22
.................... #define     RESERVED21            0x23
.................... #define     MODWIDTHREG           0x24
.................... #define     RESERVED22            0x25
.................... #define     RFCFGREG              0x26
.................... #define     GSNREG                0x27
.................... #define     CWGSPREG              0x28
.................... #define     MODGSPREG             0x29
.................... #define     TMODEREG              0x2A
.................... #define     TPRESCALERREG         0x2B
.................... #define     TRELOADREGH           0x2C
.................... #define     TRELOADREGL           0x2D
.................... #define     TCOUNTERVALUEREGH     0x2E
.................... #define     TCOUNTERVALUEREGL     0x2F
.................... //PAGE 3:TEST REGISTER     
.................... #define     RESERVED30            0x30
.................... #define     TESTSEL1REG           0x31
.................... #define     TESTSEL2REG           0x32
.................... #define     TESTPINENREG          0x33
.................... #define     TESTPINVALUEREG       0x34
.................... #define     TESTBUSREG            0x35
.................... #define     AUTOTESTREG           0x36
.................... #define     VERSIONREG            0x37
.................... #define     ANALOGTESTREG         0x38
.................... #define     TESTDAC1REG           0x39  
.................... #define     TESTDAC2REG           0x3A   
.................... #define     TESTADCREG            0x3B   
.................... #define     RESERVED31            0x3C   
.................... #define     RESERVED32            0x3D   
.................... #define     RESERVED33            0x3E   
.................... #define     RESERVED34            0x3F
.................... static void MFRC522_Wr_Old( char addr, char value )
.................... {
....................         output_bit(MFRC522_CS,0);              
....................         spi_write( ( addr << 1 ) & 0x7E );
....................         spi_write( value );
....................         output_bit(MFRC522_CS,1);
.................... }
.................... static char MFRC522_Rd_Old( char addr )
.................... {
....................       char value;
....................         output_bit(MFRC522_CS,0);                
....................         spi_write( (( addr << 1 ) & 0x7E)|0x80 );
....................         value = spi_read( 0x00 );                            
....................         output_bit(MFRC522_CS,1);     
....................         return value;
.................... } 
.................... 
.................... /*
....................  * Function:ReadReg
....................  * Description:read a byte data into one register of MR RC522
....................  * Input parameter:addr--register address
....................  * Return:return the read value
....................  */
.................... unsigned int8 MFRC522_Rd(unsigned int8 Address)  
*
0194:  BSF    03.5
0195:  CLRF   36
.................... {
....................    unsigned int i, ucAddr;
....................    unsigned int ucResult = 0;
....................    output_bit (MFRC522_SCK, 0);
0196:  BCF    03.5
0197:  BCF    07.2
0198:  BCF    2C.2
0199:  MOVF   2C,W
019A:  BSF    03.5
019B:  MOVWF  07
....................    output_bit (MFRC522_CS, 0);
019C:  BCF    03.5
019D:  BCF    07.1
019E:  BCF    2C.1
019F:  MOVF   2C,W
01A0:  BSF    03.5
01A1:  MOVWF  07
....................    ucAddr = ( (Address<<1)&0x7E)|0x80;
01A2:  BCF    03.0
01A3:  RLF    33,W
01A4:  ANDLW  7E
01A5:  IORLW  80
01A6:  MOVWF  35
....................    //Write spi
....................    FOR (i = 8; i > 0; i--)
01A7:  MOVLW  08
01A8:  MOVWF  34
01A9:  MOVF   34,F
01AA:  BTFSC  03.2
01AB:  GOTO   1CB
....................    {
....................       output_bit (MFRC522_SI, ((ucAddr&0x80) == 0x80));
01AC:  MOVF   35,W
01AD:  ANDLW  80
01AE:  SUBLW  80
01AF:  BTFSC  03.2
01B0:  GOTO   1B5
01B1:  BCF    03.5
01B2:  BCF    07.3
01B3:  GOTO   1B7
01B4:  BSF    03.5
01B5:  BCF    03.5
01B6:  BSF    07.3
01B7:  BCF    2C.3
01B8:  MOVF   2C,W
01B9:  BSF    03.5
01BA:  MOVWF  07
....................       output_bit (MFRC522_SCK, 1);
01BB:  BCF    03.5
01BC:  BSF    07.2
01BD:  BCF    2C.2
01BE:  MOVF   2C,W
01BF:  BSF    03.5
01C0:  MOVWF  07
....................       ucAddr <<= 1;
01C1:  BCF    03.0
01C2:  RLF    35,F
....................       output_bit (MFRC522_SCK, 0);
01C3:  BCF    03.5
01C4:  BCF    07.2
01C5:  BCF    2C.2
01C6:  MOVF   2C,W
01C7:  BSF    03.5
01C8:  MOVWF  07
01C9:  DECF   34,F
01CA:  GOTO   1A9
....................    }
.................... //SPI read
....................    FOR (i = 8; i > 0; i--)
01CB:  MOVLW  08
01CC:  MOVWF  34
01CD:  MOVF   34,F
01CE:  BTFSC  03.2
01CF:  GOTO   1EB
....................    {
....................       output_bit (MFRC522_SCK, 1);
01D0:  BCF    03.5
01D1:  BSF    07.2
01D2:  BCF    2C.2
01D3:  MOVF   2C,W
01D4:  BSF    03.5
01D5:  MOVWF  07
....................       ucResult <<= 1;
01D6:  BCF    03.0
01D7:  RLF    36,F
....................       ucResult|= (INT1) input (MFRC522_SO);
01D8:  BCF    03.5
01D9:  BSF    2C.4
01DA:  MOVF   2C,W
01DB:  BSF    03.5
01DC:  MOVWF  07
01DD:  MOVLW  00
01DE:  BCF    03.5
01DF:  BTFSC  07.4
01E0:  MOVLW  01
01E1:  BSF    03.5
01E2:  IORWF  36,F
....................       output_bit (MFRC522_SCK, 0);
01E3:  BCF    03.5
01E4:  BCF    07.2
01E5:  BCF    2C.2
01E6:  MOVF   2C,W
01E7:  BSF    03.5
01E8:  MOVWF  07
01E9:  DECF   34,F
01EA:  GOTO   1CD
....................    }
.................... 
....................    
....................    output_bit (MFRC522_CS, 1);
01EB:  BCF    03.5
01EC:  BSF    07.1
01ED:  BCF    2C.1
01EE:  MOVF   2C,W
01EF:  BSF    03.5
01F0:  MOVWF  07
....................    output_bit (MFRC522_SCK, 1);
01F1:  BCF    03.5
01F2:  BSF    07.2
01F3:  BCF    2C.2
01F4:  MOVF   2C,W
01F5:  BSF    03.5
01F6:  MOVWF  07
....................    RETURN ucResult;
01F7:  MOVF   36,W
01F8:  MOVWF  78
01F9:  BCF    03.5
01FA:  RETURN
.................... }
.................... 
.................... 
.................... 
.................... /*
....................  * Function:WriteReg
....................  * Description:write a byte data into one register of MR RC522
....................  * Input parameter:addr--register address;val--the value that need to write in
....................  * Return:Null
....................  */
.................... void MFRC522_Wr(unsigned int8 Address, unsigned int8 value)
.................... {
....................    
....................    unsigned int8 i, ucAddr;
....................    output_bit (MFRC522_SCK, 0);
*
012F:  BCF    07.2
0130:  BCF    2C.2
0131:  MOVF   2C,W
0132:  BSF    03.5
0133:  MOVWF  07
....................    output_bit (MFRC522_CS, 0);
0134:  BCF    03.5
0135:  BCF    07.1
0136:  BCF    2C.1
0137:  MOVF   2C,W
0138:  BSF    03.5
0139:  MOVWF  07
....................    ucAddr = ( (Address<<1)&0x7E);
013A:  BCF    03.0
013B:  RLF    34,W
013C:  ANDLW  7E
013D:  MOVWF  37
....................    FOR (i = 8; i > 0; i--)
013E:  MOVLW  08
013F:  MOVWF  36
0140:  MOVF   36,F
0141:  BTFSC  03.2
0142:  GOTO   162
....................    {
....................       output_bit (MFRC522_SI, ( (ucAddr&0x80) == 0x80));
0143:  MOVF   37,W
0144:  ANDLW  80
0145:  SUBLW  80
0146:  BTFSC  03.2
0147:  GOTO   14C
0148:  BCF    03.5
0149:  BCF    07.3
014A:  GOTO   14E
014B:  BSF    03.5
014C:  BCF    03.5
014D:  BSF    07.3
014E:  BCF    2C.3
014F:  MOVF   2C,W
0150:  BSF    03.5
0151:  MOVWF  07
....................       output_bit (MFRC522_SCK, 1);
0152:  BCF    03.5
0153:  BSF    07.2
0154:  BCF    2C.2
0155:  MOVF   2C,W
0156:  BSF    03.5
0157:  MOVWF  07
....................       ucAddr <<= 1;
0158:  BCF    03.0
0159:  RLF    37,F
....................       output_bit (MFRC522_SCK, 0);
015A:  BCF    03.5
015B:  BCF    07.2
015C:  BCF    2C.2
015D:  MOVF   2C,W
015E:  BSF    03.5
015F:  MOVWF  07
0160:  DECF   36,F
0161:  GOTO   140
....................    }
.................... 
....................    
....................    FOR (i = 8; i > 0; i--)
0162:  MOVLW  08
0163:  MOVWF  36
0164:  MOVF   36,F
0165:  BTFSC  03.2
0166:  GOTO   186
....................    {
....................       output_bit (MFRC522_SI, ( (value&0x80) == 0x80));
0167:  MOVF   35,W
0168:  ANDLW  80
0169:  SUBLW  80
016A:  BTFSC  03.2
016B:  GOTO   170
016C:  BCF    03.5
016D:  BCF    07.3
016E:  GOTO   172
016F:  BSF    03.5
0170:  BCF    03.5
0171:  BSF    07.3
0172:  BCF    2C.3
0173:  MOVF   2C,W
0174:  BSF    03.5
0175:  MOVWF  07
....................       output_bit (MFRC522_SCK, 1);
0176:  BCF    03.5
0177:  BSF    07.2
0178:  BCF    2C.2
0179:  MOVF   2C,W
017A:  BSF    03.5
017B:  MOVWF  07
....................       value <<= 1;
017C:  BCF    03.0
017D:  RLF    35,F
....................       output_bit (MFRC522_SCK, 0);
017E:  BCF    03.5
017F:  BCF    07.2
0180:  BCF    2C.2
0181:  MOVF   2C,W
0182:  BSF    03.5
0183:  MOVWF  07
0184:  DECF   36,F
0185:  GOTO   164
....................    }
.................... 
....................    output_bit (MFRC522_CS, 1);
0186:  BCF    03.5
0187:  BSF    07.1
0188:  BCF    2C.1
0189:  MOVF   2C,W
018A:  BSF    03.5
018B:  MOVWF  07
....................    output_bit (MFRC522_SCK, 1);
018C:  BCF    03.5
018D:  BSF    07.2
018E:  BCF    2C.2
018F:  MOVF   2C,W
0190:  BSF    03.5
0191:  MOVWF  07
0192:  BCF    03.5
0193:  RETURN
.................... }
.................... 
.................... 
.................... 
....................  
....................  
....................  /*
....................  * Function:ClearBitMask
....................  * Description:clear RC522 register bit
....................  * Input parameter:reg--register address;mask--value
....................  * Return:null
....................  */
.................... static void MFRC522_Clear_Bit( char addr, char mask )
*
01FB:  BSF    03.5
01FC:  CLRF   32
.................... {     
....................    unsigned int8  tmp =0x0; 
....................     tmp=MFRC522_Rd( addr ) ;
01FD:  MOVF   30,W
01FE:  MOVWF  33
01FF:  BCF    03.5
0200:  CALL   194
0201:  MOVF   78,W
0202:  BSF    03.5
0203:  MOVWF  32
....................     MFRC522_Wr( addr,  tmp&~mask );     // tmp&(~mask)
0204:  MOVF   31,W
0205:  XORLW  FF
0206:  ANDWF  32,W
0207:  MOVWF  33
0208:  MOVF   30,W
0209:  MOVWF  34
020A:  MOVF   33,W
020B:  MOVWF  35
020C:  BCF    03.5
020D:  CALL   12F
020E:  RETURN
.................... }
.................... 
.................... 
.................... /*
....................  * Function:SetBitMask
....................  * Description:set RC522 register bit
....................  * Input parameter:reg--register address;mask--value
....................  * Return:null
....................  */
.................... static void MFRC522_Set_Bit( char addr, char mask )
020F:  BSF    03.5
0210:  CLRF   32
.................... {   
....................    unsigned int8  tmp =0x0; 
....................     tmp=MFRC522_Rd( addr ) ;  
0211:  MOVF   30,W
0212:  MOVWF  33
0213:  BCF    03.5
0214:  CALL   194
0215:  MOVF   78,W
0216:  BSF    03.5
0217:  MOVWF  32
....................     MFRC522_Wr( addr, tmp|mask );
0218:  MOVF   32,W
0219:  IORWF  31,W
021A:  MOVWF  33
021B:  MOVF   30,W
021C:  MOVWF  34
021D:  MOVF   33,W
021E:  MOVWF  35
021F:  BCF    03.5
0220:  CALL   12F
0221:  RETURN
.................... }
.................... 
.................... 
.................... /*
....................  * Function:Reset
....................  * Description: reset RC522
....................  * Input parameter:null
....................  * Return:null
....................  */
.................... void MFRC522_Reset()
.................... {  
....................    output_bit (MFRC522_RST, 1) ;
*
022D:  BCF    03.5
022E:  BSF    07.5
022F:  BCF    2C.5
0230:  MOVF   2C,W
0231:  BSF    03.5
0232:  MOVWF  07
....................    delay_us (1);
0233:  GOTO   234
0234:  GOTO   235
0235:  NOP
....................    output_bit (MFRC522_RST, 0) ;
0236:  BCF    03.5
0237:  BCF    07.5
0238:  BCF    2C.5
0239:  MOVF   2C,W
023A:  BSF    03.5
023B:  MOVWF  07
....................    delay_us (1);
023C:  GOTO   23D
023D:  GOTO   23E
023E:  NOP
....................    output_bit (MFRC522_RST, 1) ;
023F:  BCF    03.5
0240:  BSF    07.5
0241:  BCF    2C.5
0242:  MOVF   2C,W
0243:  BSF    03.5
0244:  MOVWF  07
....................    delay_us (1);
0245:  GOTO   246
0246:  GOTO   247
0247:  NOP
....................    MFRC522_Wr( COMMANDREG, PCD_RESETPHASE ); 
0248:  MOVLW  01
0249:  MOVWF  34
024A:  MOVLW  0F
024B:  MOVWF  35
024C:  BCF    03.5
024D:  CALL   12F
....................    delay_us (1);
024E:  GOTO   24F
024F:  GOTO   250
0250:  NOP
.................... }
.................... 
.................... /*
....................  * Function:AntennaOn
....................  * Description:Turn on antenna, every time turn on or shut down antenna need at least 1ms delay
....................  * Input parameter:null
....................  * Return:null
....................  */
.................... void MFRC522_AntennaOn()
.................... {                                               
....................    unsigned int8 stt;
....................    stt= MFRC522_Rd( TXCONTROLREG ) ;
*
0281:  MOVLW  14
0282:  BSF    03.5
0283:  MOVWF  33
0284:  BCF    03.5
0285:  CALL   194
0286:  MOVF   78,W
0287:  MOVWF  74
....................    MFRC522_Set_Bit( TXCONTROLREG, 0x03 ); 
0288:  MOVLW  14
0289:  BSF    03.5
028A:  MOVWF  30
028B:  MOVLW  03
028C:  MOVWF  31
028D:  BCF    03.5
028E:  CALL   20F
....................    //!if(! (stt&0x03)){                                     
....................    //! MFRC522_Set_Bit( TXCONTROLREG, 0x03 ); 
....................    //!}
.................... }
.................... 
.................... /*
....................  * Function:AntennaOff
....................  * Description:Turn off antenna, every time turn on or shut down antenna need at least 1ms delay
....................  * Input parameter:null
....................  * Return:null
....................  */
.................... void MFRC522_AntennaOff()
.................... {
....................  MFRC522_Clear_Bit( TXCONTROLREG, 0x03 );                                           
*
027A:  MOVLW  14
027B:  BSF    03.5
027C:  MOVWF  30
027D:  MOVLW  03
027E:  MOVWF  31
027F:  BCF    03.5
0280:  CALL   1FB
.................... }
.................... 
.................... 
.................... /*
....................  * Function:Init
....................  * Description:initilize RC522
....................  * Input parameter:null
....................  * Return:null
....................  */
.................... void MFRC522_Init()      
.................... {
....................                                                               
....................     output_bit(MFRC522_CS , 1);  
*
0222:  BSF    07.1
0223:  BCF    2C.1
0224:  MOVF   2C,W
0225:  BSF    03.5
0226:  MOVWF  07
....................     output_bit( MFRC522_RST , 1); 
0227:  BCF    03.5
0228:  BSF    07.5
0229:  BCF    2C.5
022A:  MOVF   2C,W
022B:  BSF    03.5
022C:  MOVWF  07
....................     
....................      MFRC522_Reset();        
....................      MFRC522_Wr( TMODEREG, 0x8D );      //Tauto=1; f(Timer) = 6.78MHz/TPreScaler
*
0251:  MOVLW  2A
0252:  BSF    03.5
0253:  MOVWF  34
0254:  MOVLW  8D
0255:  MOVWF  35
0256:  BCF    03.5
0257:  CALL   12F
....................      MFRC522_Wr( TPRESCALERREG, 0x3E ); //TModeReg[3..0] + TPrescalerReg 
0258:  MOVLW  2B
0259:  BSF    03.5
025A:  MOVWF  34
025B:  MOVLW  3E
025C:  MOVWF  35
025D:  BCF    03.5
025E:  CALL   12F
....................      MFRC522_Wr( TRELOADREGL, 30 ); 
025F:  MOVLW  2D
0260:  BSF    03.5
0261:  MOVWF  34
0262:  MOVLW  1E
0263:  MOVWF  35
0264:  BCF    03.5
0265:  CALL   12F
....................      MFRC522_Wr( TRELOADREGH, 0 );  
0266:  MOVLW  2C
0267:  BSF    03.5
0268:  MOVWF  34
0269:  CLRF   35
026A:  BCF    03.5
026B:  CALL   12F
....................      MFRC522_Wr( TXAUTOREG, 0x40 );    //100%ASK
026C:  MOVLW  15
026D:  BSF    03.5
026E:  MOVWF  34
026F:  MOVLW  40
0270:  MOVWF  35
0271:  BCF    03.5
0272:  CALL   12F
....................      MFRC522_Wr( MODEREG, 0x3D );      // CRC valor inicial de 0x6363
0273:  MOVLW  11
0274:  BSF    03.5
0275:  MOVWF  34
0276:  MOVLW  3D
0277:  MOVWF  35
0278:  BCF    03.5
0279:  CALL   12F
....................         
....................      //MFRC522_Clear_Bit( STATUS2REG, 0x08 );//MFCrypto1On=0
....................      //MFRC522_Wr( RXSELREG, 0x86 );      //RxWait = RxSelReg[5..0]
....................      //MFRC522_Wr( RFCFGREG, 0x7F );     //RxGain = 48dB
....................      MFRC522_AntennaOff() ;             
....................      MFRC522_AntennaOn();
*
028F:  BSF    0A.3
0290:  BCF    0A.4
0291:  GOTO   1D1 (RETURN)
.................... }
.................... 
.................... /*
....................  * Function:ToCard
....................  * Description:communicate between RC522 and ISO14443
....................  * Input parameter:command--MF522 command bits
....................  *          sendData--send data to card via rc522
....................  *          sendLen--send data length       
....................  *          backData--the return data from card
....................  *          backLen--the length of return data
....................  * return:return MI_OK if successed
....................  */
.................... char MFRC522_ToCard( char command, char *sendData, char sendLen, char *backData, unsigned *backLen )
*
05FF:  MOVLW  02
0600:  BSF    03.5
0601:  MOVWF  2A
0602:  CLRF   2B
0603:  CLRF   2C
.................... {
....................   char _status = MI_ERR;
....................   char irqEn = 0x00;
....................   char waitIRq = 0x00;                
....................   char lastBits;
....................   char n;
....................   unsigned i;
....................   
....................   switch (command)
0604:  MOVF   22,W
0605:  XORLW  0E
0606:  BCF    03.5
0607:  BTFSC  03.2
0608:  GOTO   60D
0609:  XORLW  02
060A:  BTFSC  03.2
060B:  GOTO   614
060C:  GOTO   61B
....................   {
....................     case PCD_AUTHENT:       //Certification cards close
....................     {
....................       irqEn = 0x12;
060D:  MOVLW  12
060E:  BSF    03.5
060F:  MOVWF  2B
....................       waitIRq = 0x10;
0610:  MOVLW  10
0611:  MOVWF  2C
....................       break;
0612:  GOTO   61C
0613:  BCF    03.5
....................     }
....................     case PCD_TRANSCEIVE:    //Transmit FIFO data
....................     {
....................       irqEn = 0x77;
0614:  MOVLW  77
0615:  BSF    03.5
0616:  MOVWF  2B
....................       waitIRq = 0x30;
0617:  MOVLW  30
0618:  MOVWF  2C
....................       break;
0619:  GOTO   61C
061A:  BCF    03.5
....................     }
....................     default:
....................       break;
061B:  BSF    03.5
....................   }
....................   MFRC522_Wr( COMMIENREG, irqEn | 0x80 );  //Interrupt request
061C:  MOVF   2B,W
061D:  IORLW  80
061E:  MOVWF  30
061F:  MOVLW  02
0620:  MOVWF  34
0621:  MOVF   30,W
0622:  MOVWF  35
0623:  BCF    03.5
0624:  CALL   12F
....................   MFRC522_Clear_Bit( COMMIRQREG, 0x80 );   //Clear all interrupt request bit
0625:  MOVLW  04
0626:  BSF    03.5
0627:  MOVWF  30
0628:  MOVLW  80
0629:  MOVWF  31
062A:  BCF    03.5
062B:  CALL   1FB
....................   MFRC522_Set_Bit( FIFOLEVELREG, 0x80 );   //FlushBuffer=1, FIFO Initialization
062C:  MOVLW  0A
062D:  BSF    03.5
062E:  MOVWF  30
062F:  MOVLW  80
0630:  MOVWF  31
0631:  BCF    03.5
0632:  CALL   20F
....................   MFRC522_Wr( COMMANDREG, PCD_IDLE );      //NO action; Cancel the current command???
0633:  MOVLW  01
0634:  BSF    03.5
0635:  MOVWF  34
0636:  CLRF   35
0637:  BCF    03.5
0638:  CALL   12F
....................   
....................   //Writing data to the FIFO
....................   for ( i=0; i < sendLen; i++ )
0639:  BSF    03.5
063A:  CLRF   2F
063B:  MOVF   25,W
063C:  SUBWF  2F,W
063D:  BTFSC  03.0
063E:  GOTO   650
....................   {
....................     MFRC522_Wr( FIFODATAREG, sendData[i] );
063F:  MOVF   2F,W
0640:  ADDWF  23,W
0641:  MOVWF  04
0642:  BCF    03.7
0643:  BTFSC  24.0
0644:  BSF    03.7
0645:  MOVF   00,W
0646:  MOVWF  30
0647:  MOVLW  09
0648:  MOVWF  34
0649:  MOVF   30,W
064A:  MOVWF  35
064B:  BCF    03.5
064C:  CALL   12F
064D:  BSF    03.5
064E:  INCF   2F,F
064F:  GOTO   63B
....................   }
....................   //Execute the command
....................   MFRC522_Wr( COMMANDREG, command );
0650:  MOVLW  01
0651:  MOVWF  34
0652:  MOVF   22,W
0653:  MOVWF  35
0654:  BCF    03.5
0655:  CALL   12F
....................   if (command == PCD_TRANSCEIVE )
0656:  BSF    03.5
0657:  MOVF   22,W
0658:  SUBLW  0C
0659:  BTFSS  03.2
065A:  GOTO   662
....................   {
....................     MFRC522_Set_Bit( BITFRAMINGREG, 0x80 ); //StartSend=1,transmission of data starts  
065B:  MOVLW  0D
065C:  MOVWF  30
065D:  MOVLW  80
065E:  MOVWF  31
065F:  BCF    03.5
0660:  CALL   20F
0661:  BSF    03.5
....................   }
....................   //Waiting to receive data to complete
....................   //i according to the clock frequency adjustment, the operator M1 card maximum waiting time 25ms???
....................   i = 0xFFFF;   
0662:  MOVLW  FF
0663:  MOVWF  2F
....................   do
....................   {
....................     //CommIrqReg[7..0]
....................     //Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq
....................     n = MFRC522_Rd( COMMIRQREG );
0664:  MOVLW  04
0665:  MOVWF  33
0666:  BCF    03.5
0667:  CALL   194
0668:  MOVF   78,W
0669:  BSF    03.5
066A:  MOVWF  2E
....................     i--;
066B:  DECF   2F,F
....................   }
....................   while ( i && !(n & 0x01) && !( n & waitIRq ) );
066C:  MOVF   2F,F
066D:  BTFSC  03.2
066E:  GOTO   675
066F:  BTFSC  2E.0
0670:  GOTO   675
0671:  MOVF   2E,W
0672:  ANDWF  2C,W
0673:  BTFSC  03.2
0674:  GOTO   664
....................   MFRC522_Clear_Bit( BITFRAMINGREG, 0x80 );    //StartSend=0
0675:  MOVLW  0D
0676:  MOVWF  30
0677:  MOVLW  80
0678:  MOVWF  31
0679:  BCF    03.5
067A:  CALL   1FB
....................   if (i != 0)
067B:  BSF    03.5
067C:  MOVF   2F,F
067D:  BTFSC  03.2
067E:  GOTO   6F9
....................   {
....................     if( !( MFRC522_Rd( ERRORREG ) & 0x1B ) ) //BufferOvfl Collerr CRCErr ProtecolErr
067F:  MOVLW  06
0680:  MOVWF  33
0681:  BCF    03.5
0682:  CALL   194
0683:  MOVF   78,W
0684:  ANDLW  1B
0685:  BTFSS  03.2
0686:  GOTO   6F6
....................     {
....................       _status = MI_OK;
0687:  BSF    03.5
0688:  CLRF   2A
....................       if ( n & irqEn & 0x01 )
0689:  MOVF   2E,W
068A:  ANDWF  2B,W
068B:  ANDLW  01
068C:  BTFSC  03.2
068D:  GOTO   690
....................       {
....................         _status = MI_NOTAGERR;       //??
068E:  MOVLW  01
068F:  MOVWF  2A
....................       }
....................       if ( command == PCD_TRANSCEIVE )
0690:  MOVF   22,W
0691:  SUBLW  0C
0692:  BTFSS  03.2
0693:  GOTO   6F4
....................       {
....................         n = MFRC522_Rd( FIFOLEVELREG );
0694:  MOVLW  0A
0695:  MOVWF  33
0696:  BCF    03.5
0697:  CALL   194
0698:  MOVF   78,W
0699:  BSF    03.5
069A:  MOVWF  2E
....................         lastBits = MFRC522_Rd( CONTROLREG ) & 0x07;
069B:  MOVLW  0C
069C:  MOVWF  33
069D:  BCF    03.5
069E:  CALL   194
069F:  MOVF   78,W
06A0:  ANDLW  07
06A1:  BSF    03.5
06A2:  MOVWF  2D
....................         if (lastBits)
06A3:  MOVF   2D,F
06A4:  BTFSC  03.2
06A5:  GOTO   6B7
....................         {
....................           *backLen = (n-1) * 8 + lastBits;
06A6:  MOVF   28,W
06A7:  MOVWF  04
06A8:  BCF    03.7
06A9:  BTFSC  29.0
06AA:  BSF    03.7
06AB:  MOVLW  01
06AC:  SUBWF  2E,W
06AD:  MOVWF  77
06AE:  RLF    77,F
06AF:  RLF    77,F
06B0:  RLF    77,F
06B1:  MOVLW  F8
06B2:  ANDWF  77,F
06B3:  MOVF   77,W
06B4:  ADDWF  2D,W
06B5:  MOVWF  00
....................         }
06B6:  GOTO   6C4
....................         else
....................         {
....................           *backLen = n * 8;
06B7:  MOVF   28,W
06B8:  MOVWF  04
06B9:  BCF    03.7
06BA:  BTFSC  29.0
06BB:  BSF    03.7
06BC:  RLF    2E,W
06BD:  MOVWF  77
06BE:  RLF    77,F
06BF:  RLF    77,F
06C0:  MOVLW  F8
06C1:  ANDWF  77,F
06C2:  MOVF   77,W
06C3:  MOVWF  00
....................         }
....................         if (n == 0)
06C4:  MOVF   2E,F
06C5:  BTFSS  03.2
06C6:  GOTO   6C9
....................         {
....................           n = 1;
06C7:  MOVLW  01
06C8:  MOVWF  2E
....................         }
....................         if (n > 16)
06C9:  MOVF   2E,W
06CA:  SUBLW  10
06CB:  BTFSC  03.0
06CC:  GOTO   6CF
....................         {
....................           n = 16;
06CD:  MOVLW  10
06CE:  MOVWF  2E
....................         }
....................         //Reading the received data in FIFO
....................         for (i=0; i < n; i++)
06CF:  CLRF   2F
06D0:  MOVF   2E,W
06D1:  SUBWF  2F,W
06D2:  BTFSC  03.0
06D3:  GOTO   6ED
....................         {
....................           backData[i] = MFRC522_Rd( FIFODATAREG );
06D4:  MOVF   2F,W
06D5:  ADDWF  26,W
06D6:  MOVWF  78
06D7:  MOVF   27,W
06D8:  MOVWF  7A
06D9:  BTFSC  03.0
06DA:  INCF   7A,F
06DB:  MOVF   78,W
06DC:  MOVWF  30
06DD:  MOVF   7A,W
06DE:  MOVWF  31
06DF:  MOVLW  09
06E0:  MOVWF  33
06E1:  BCF    03.5
06E2:  CALL   194
06E3:  BSF    03.5
06E4:  MOVF   30,W
06E5:  MOVWF  04
06E6:  BCF    03.7
06E7:  BTFSC  31.0
06E8:  BSF    03.7
06E9:  MOVF   78,W
06EA:  MOVWF  00
06EB:  INCF   2F,F
06EC:  GOTO   6D0
....................         }
....................   
....................   backData[i] = 0;
06ED:  MOVF   2F,W
06EE:  ADDWF  26,W
06EF:  MOVWF  04
06F0:  BCF    03.7
06F1:  BTFSC  27.0
06F2:  BSF    03.7
06F3:  CLRF   00
....................       }
....................     }
06F4:  GOTO   6F9
06F5:  BCF    03.5
....................     else
....................     {
....................       _status = MI_ERR;
06F6:  MOVLW  02
06F7:  BSF    03.5
06F8:  MOVWF  2A
....................     }
....................   }
....................   //MFRC522_Set_Bit( CONTROLREG, 0x80 );
....................   //MFRC522_Wr( COMMANDREG, PCD_IDLE );
....................   return _status;
06F9:  MOVF   2A,W
06FA:  MOVWF  78
06FB:  BCF    03.5
06FC:  RETURN
.................... }
.................... 
.................... 
.................... /*
....................  * Function:Request
....................  * Description:Searching card, read card type
....................  * Input parameter:reqMode--search methods,
....................  *          TagType--return card types
....................  *            0x4400 = Mifare_UltraLight
....................  *            0x0400 = Mifare_One(S50)
....................  *            0x0200 = Mifare_One(S70)
....................  *            0x0800 = Mifare_Pro(X)
....................  *            0x4403 = Mifare_DESFire
....................  * return:return MI_OK if successed
....................  */
.................... char MFRC522_Request( char reqMode, char *TagType )
.................... {
....................   char _status;
....................   unsigned backBits;            //The received data bits
....................   MFRC522_Wr( BITFRAMINGREG, 0x07 ); //TxLastBists = BitFramingReg[2..0]   ???
*
0703:  MOVLW  0D
0704:  BSF    03.5
0705:  MOVWF  34
0706:  MOVLW  07
0707:  MOVWF  35
0708:  BCF    03.5
0709:  CALL   12F
....................   TagType[0] = reqMode;
070A:  MOVF   7B,W
070B:  MOVWF  04
070C:  BCF    03.7
070D:  BTFSC  7C.0
070E:  BSF    03.7
070F:  MOVF   76,W
0710:  MOVWF  00
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, TagType, 1, TagType, &backBits );
0711:  MOVLW  0C
0712:  BSF    03.5
0713:  MOVWF  22
0714:  MOVF   7C,W
0715:  MOVWF  24
0716:  MOVF   7B,W
0717:  MOVWF  23
0718:  MOVLW  01
0719:  MOVWF  25
071A:  MOVF   7C,W
071B:  MOVWF  27
071C:  MOVF   7B,W
071D:  MOVWF  26
071E:  CLRF   29
071F:  MOVLW  7E
0720:  MOVWF  28
0721:  BCF    03.5
0722:  CALL   5FF
0723:  MOVF   78,W
0724:  MOVWF  7D
....................   if ( (_status != MI_OK) || (backBits != 0x10) )
0725:  MOVF   7D,F
0726:  BTFSS  03.2
0727:  GOTO   72C
0728:  MOVF   7E,W
0729:  SUBLW  10
072A:  BTFSC  03.2
072B:  GOTO   72E
....................   {
....................     _status = MI_ERR;
072C:  MOVLW  02
072D:  MOVWF  7D
....................   }
....................   return _status;
072E:  MOVF   7D,W
072F:  MOVWF  78
.................... }
.................... 
.................... 
.................... 
.................... /*
....................  * Function:CalulateCRC
....................  * Description:Use MF522 to calculate CRC
....................  * Input parameter:pIndata--the CRC data need to be read,len--data length,pOutData-- the caculated result of CRC
....................  * return:Null
....................  */
.................... void MFRC522_CRC( char *dataIn, char length, char *dataOut )
.................... {
.................... char i, n;
....................     MFRC522_Clear_Bit( DIVIRQREG, 0x04 );
....................     MFRC522_Set_Bit( FIFOLEVELREG, 0x80 );    
....................     
....................  //Escreve dados no FIFO        
....................     for ( i = 0; i < length; i++ )
....................     {   
....................         MFRC522_Wr( FIFODATAREG, *dataIn++ );   
....................     }
....................     
....................     MFRC522_Wr( COMMANDREG, PCD_CALCCRC );
....................         
....................     i = 0xFF;
....................     //Espera a finalizao do Calculo do CRC
....................     do 
....................     {
....................         n = MFRC522_Rd( DIVIRQREG );
....................         i--;
....................     }
....................     while( i && !(n & 0x04) );        //CRCIrq = 1
....................         
....................     dataOut[0] = MFRC522_Rd( CRCRESULTREGL );
....................     dataOut[1] = MFRC522_Rd( CRCRESULTREGM );        
.................... }
.................... 
.................... 
.................... 
.................... /*
....................  * Function:SelectTag
....................  * Description:Select card, read card storage volume
....................  * Input parameter:serNum--Send card serial number
....................  * return:return the card storage volume
....................  */
.................... char MFRC522_SelectTag( char *serNum )
.................... {
....................   char i;
....................   char _status;
....................   char size;
....................   unsigned recvBits;
....................   char buffer[9];
....................   
....................   //MFRC522_Clear_Bit( STATUS2REG, 0x08 );   //MFCrypto1On=0
....................   
....................   buffer[0] = PICC_SElECTTAG;
....................   buffer[1] = 0x70;
....................   
....................   for ( i=2; i < 7; i++ )
....................   {
....................     buffer[i] = *serNum++;
....................   }
....................   
....................   MFRC522_CRC( buffer, 7, &buffer[7] );             
....................   
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, buffer, 9, buffer, &recvBits );
....................   if ( (_status == MI_OK) && (recvBits == 0x18) )
....................   {
....................     size = buffer[0];
....................   }
....................   else
....................   {
....................     size = 0;
....................   }
....................   return size;
.................... }
.................... 
.................... 
.................... 
.................... 
.................... /*
....................  * Function:Halt hibernation (ngu dong)
....................  * Description:Command the cards into sleep mode
....................  * Input parameters:null
....................  * return:null
....................  */
.................... void MFRC522_Halt()
.................... {
....................   unsigned unLen;
....................   char buff[4];
....................   
....................   buff[0] = PICC_HALT;
....................   buff[1] = 0;
....................   MFRC522_CRC( buff, 2, &buff[2] );
....................   MFRC522_Clear_Bit( STATUS2REG, 0x80 );
....................   MFRC522_ToCard( PCD_TRANSCEIVE, buff, 4, buff, &unLen );
....................   MFRC522_Clear_Bit( STATUS2REG, 0x08 );
.................... }
.................... 
.................... 
.................... 
.................... /*
....................  * Function:Auth Xac thuc ma key 
....................  * Description:verify card password
....................  * Input parameters:authMode--password verify mode
....................                  0x60 = verify A password key 
....................                  0x61 = verify B password key 
....................              BlockAddr--Block address
....................              Sectorkey--Block password
....................              serNum--Card serial number ,4 bytes
....................  * return:return MI_OK if successed
....................  */
.................... char MFRC522_Auth( char authMode, char BlockAddr, char *Sectorkey, char *serNum )
.................... {
....................   char _status;
....................   unsigned recvBits;
....................   char i;
....................   char buff[12];
....................   
....................   //Verify the command block address + sector + password + card serial number
....................   buff[0] = authMode;
....................   buff[1] = BlockAddr;
....................   
....................   for ( i = 2; i < 8; i++ )
....................   {
....................     buff[i] = Sectorkey[i-2];
....................   }
....................   
....................   for ( i = 8; i < 12; i++ )
....................   {
....................     buff[i] = serNum[i-8];
....................   }
....................   
....................   _status = MFRC522_ToCard( PCD_AUTHENT, buff, 12, buff, &recvBits );
....................   
....................   if ( ( _status != MI_OK ) || !( MFRC522_Rd( STATUS2REG ) & 0x08 ) )
....................   {
....................     _status = MI_ERR;
....................   }
....................   
....................   return _status;
.................... }
.................... 
.................... 
.................... /*
....................  * Function:MFRC522_Write
....................  * Description:write block data
....................  * Input parameters:blockAddr--block address;writeData--Write 16 bytes data into block
....................  * return:return MI_OK if successed
....................  */
.................... char MFRC522_Write( char blockAddr, char *writeData )
.................... {
....................   char _status;
....................   unsigned recvBits;
....................   char i;
....................   char buff[18];
....................   buff[0] = PICC_WRITE;
....................   buff[1] = blockAddr;
....................   
....................   MFRC522_CRC( buff, 2, &buff[2] );
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, buff, 4, buff, &recvBits );
....................   if ( (_status != MI_OK) || (recvBits != 4) || ( (buff[0] & 0x0F) != 0x0A) )
....................   {
....................     _status = MI_ERR;
....................   }
....................   if (_status == MI_OK)
....................   {
....................     for ( i = 0; i < 16; i++ )                //Data to the FIFO write 16Byte
....................     {
....................       buff[i] = writeData[i];
....................     }
....................     
....................     MFRC522_CRC( buff, 16, &buff[16] );
....................     _status = MFRC522_ToCard( PCD_TRANSCEIVE, buff, 18, buff, &recvBits );
....................     if ( (_status != MI_OK) || (recvBits != 4) || ( (buff[0] & 0x0F) != 0x0A ) )
....................     {
....................       _status = MI_ERR;
....................     }
....................   }
....................   return _status;
.................... }
.................... 
.................... 
.................... /*
....................  * Function:MFRC522_Read
....................  * Description:Read data 
....................  * Input parameters:blockAddr--block address;recvData--the block data which are read
....................  * return:return MI_OK if successed
....................  */
.................... char MFRC522_Read( char blockAddr, char *recvData )
.................... {
....................   char _status;
....................   unsigned unLen;
....................   recvData[0] = PICC_READ;
....................   recvData[1] = blockAddr;
....................   
....................   MFRC522_CRC( recvData, 2, &recvData[2] );
....................   
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, recvData, 4, recvData, &unLen );
....................   if ( (_status != MI_OK) || (unLen != 0x90) )
....................   {
....................     _status = MI_ERR;
....................   }
....................   return _status;
.................... }
.................... 
.................... 
.................... /*
....................  * Function:MFRC522_Anticoll
....................  * Description:Prevent conflict, read the card serial number 
....................  * Input parameter:serNum--return the 4 bytes card serial number, the 5th byte is recheck byte
....................  * return:return MI_OK if successed
....................  */
.................... char MFRC522_AntiColl( char *serNum )
*
073E:  BSF    03.5
073F:  CLRF   20
.................... {
....................   char _status;
....................   char i;
....................   char serNumCheck = 0;
....................   unsigned unLen;
....................   MFRC522_Wr( BITFRAMINGREG, 0x00 );                //TxLastBists = BitFramingReg[2..0]
0740:  MOVLW  0D
0741:  MOVWF  34
0742:  CLRF   35
0743:  BCF    03.5
0744:  CALL   12F
....................   serNum[0] = PICC_ANTICOLL;
0745:  MOVF   7B,W
0746:  MOVWF  04
0747:  BCF    03.7
0748:  BTFSC  7C.0
0749:  BSF    03.7
074A:  MOVLW  93
074B:  MOVWF  00
....................   serNum[1] = 0x20;
074C:  MOVLW  01
074D:  ADDWF  7B,W
074E:  MOVWF  04
074F:  BCF    03.7
0750:  BTFSC  7C.0
0751:  BSF    03.7
0752:  MOVLW  20
0753:  MOVWF  00
....................   MFRC522_Clear_Bit( STATUS2REG, 0x08 );
0754:  MOVLW  08
0755:  BSF    03.5
0756:  MOVWF  30
0757:  MOVWF  31
0758:  BCF    03.5
0759:  CALL   1FB
....................   _status = MFRC522_ToCard( PCD_TRANSCEIVE, serNum, 2, serNum, &unLen );
075A:  MOVLW  0C
075B:  BSF    03.5
075C:  MOVWF  22
075D:  MOVF   7C,W
075E:  MOVWF  24
075F:  MOVF   7B,W
0760:  MOVWF  23
0761:  MOVLW  02
0762:  MOVWF  25
0763:  MOVF   7C,W
0764:  MOVWF  27
0765:  MOVF   7B,W
0766:  MOVWF  26
0767:  CLRF   29
0768:  MOVLW  A1
0769:  MOVWF  28
076A:  BCF    03.5
076B:  CALL   5FF
076C:  MOVF   78,W
076D:  MOVWF  7D
....................   if (_status == MI_OK)
076E:  MOVF   7D,F
076F:  BTFSS  03.2
0770:  GOTO   790
....................   {
....................     for ( i=0; i < 4; i++ )
0771:  CLRF   7E
0772:  MOVF   7E,W
0773:  SUBLW  03
0774:  BTFSS  03.0
0775:  GOTO   782
....................     {
....................       serNumCheck ^= serNum[i];
0776:  MOVF   7E,W
0777:  ADDWF  7B,W
0778:  MOVWF  04
0779:  BCF    03.7
077A:  BTFSC  7C.0
077B:  BSF    03.7
077C:  MOVF   00,W
077D:  BSF    03.5
077E:  XORWF  20,F
077F:  INCF   7E,F
0780:  BCF    03.5
0781:  GOTO   772
....................     }
....................     
....................     if ( serNumCheck != serNum[4] )
0782:  MOVLW  04
0783:  ADDWF  7B,W
0784:  MOVWF  04
0785:  BCF    03.7
0786:  BTFSC  7C.0
0787:  BSF    03.7
0788:  MOVF   00,W
0789:  BSF    03.5
078A:  SUBWF  20,W
078B:  BTFSC  03.2
078C:  GOTO   78F
....................     {
....................       _status = MI_ERR;
078D:  MOVLW  02
078E:  MOVWF  7D
078F:  BCF    03.5
....................     }
....................   }
....................   return _status;
0790:  MOVF   7D,W
0791:  MOVWF  78
.................... }
.................... 
.................... 
.................... //0x0044 = Mifare_UltraLight
.................... //0x0004 = Mifare_One (S50)
.................... //0x0002 = Mifare_One (S70)
.................... //0x0008 = Mifare_Pro (X)
.................... //0x0344 = Mifare_DESFire
.................... //Kiem tra the
.................... char MFRC522_isCard( char *TagType ) 
.................... {
....................     if (MFRC522_Request( PICC_REQIDL, TagType ) == MI_OK)
*
06FD:  MOVLW  26
06FE:  MOVWF  76
06FF:  MOVF   75,W
0700:  MOVWF  7C
0701:  MOVF   74,W
0702:  MOVWF  7B
*
0730:  MOVF   78,F
0731:  BTFSS  03.2
0732:  GOTO   737
....................         return 1;
0733:  MOVLW  01
0734:  MOVWF  78
0735:  GOTO   739
0736:  GOTO   739
....................     else
....................         return 0; 
0737:  MOVLW  00
0738:  MOVWF  78
0739:  RETURN
.................... }
.................... 
.................... 
.................... /*
....................  * Description:Read the serial number of the card.
....................  */
.................... char MFRC522_ReadCardSerial( char *str )
.................... {
.................... char _status; 
....................  _status = MFRC522_AntiColl( str );
073A:  MOVF   75,W
073B:  MOVWF  7C
073C:  MOVF   74,W
073D:  MOVWF  7B
*
0792:  MOVF   78,W
0793:  MOVWF  76
....................  str[5] = 0;
0794:  MOVLW  05
0795:  ADDWF  74,W
0796:  MOVWF  04
0797:  BCF    03.7
0798:  BTFSC  75.0
0799:  BSF    03.7
079A:  CLRF   00
....................  if (_status == MI_OK)
079B:  MOVF   76,F
079C:  BTFSS  03.2
079D:  GOTO   7A2
....................   return 1;
079E:  MOVLW  01
079F:  MOVWF  78
07A0:  GOTO   7A4
07A1:  GOTO   7A4
....................  else
....................   return 0;
07A2:  MOVLW  00
07A3:  MOVWF  78
07A4:  RETURN
.................... }
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
09BE:  BCF    03.5
09BF:  CLRF   2D
09C0:  CLRF   2E
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #use rs232(baud=115200,parity =N, xmit=pin_c6,rcv=pin_c7,bits=8) 
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used FOR I/O
.................... 
.................... 
.................... #define BUFFER_SIZE 11
.................... BYTE buffer[32];
.................... BYTE next_in = 0;
.................... BYTE next_out = 0;
.................... 
.................... unsigned int8 bdt;
.................... //Ham ngat timer1
.................... #INT_TIMER1
.................... void ngat()
.................... {
....................    bdt++;
*
005A:  INCF   55,F
....................    set_timer1(3036);
005B:  CLRF   0E
005C:  MOVLW  0B
005D:  MOVWF  0F
005E:  MOVLW  DC
005F:  MOVWF  0E
0060:  NOP
.................... //!   if(bdt>100)
.................... //!   bdt = 100;
....................   
.................... }
.................... 
.................... //
.................... 
0061:  BCF    0C.0
0062:  BCF    0A.3
0063:  BCF    0A.4
0064:  GOTO   033
.................... #int_rda
.................... void serial_isr() {
....................    int t;
.................... 
....................    buffer[next_in]=getc();
*
007C:  MOVLW  33
007D:  ADDWF  53,W
007E:  MOVWF  04
007F:  BCF    03.7
0080:  BTFSS  0C.5
0081:  GOTO   080
0082:  MOVF   1A,W
0083:  MOVWF  00
....................    t=next_in;
0084:  MOVF   53,W
0085:  BSF    03.5
0086:  MOVWF  3C
....................    next_in=(next_in+1) % BUFFER_SIZE;
0087:  MOVLW  01
0088:  BCF    03.5
0089:  ADDWF  53,W
008A:  BSF    03.5
008B:  MOVWF  3E
008C:  MOVWF  3F
008D:  MOVLW  0B
008E:  MOVWF  40
008F:  BCF    03.5
0090:  CALL   065
0091:  MOVF   77,W
0092:  MOVWF  53
....................    if(next_in==next_out)
0093:  MOVF   54,W
0094:  SUBWF  53,W
0095:  BTFSS  03.2
0096:  GOTO   09B
....................      next_in=t;           // Buffer full !!
0097:  BSF    03.5
0098:  MOVF   3C,W
0099:  BCF    03.5
009A:  MOVWF  53
.................... }
.................... 
009B:  BCF    0C.5
009C:  BCF    0A.3
009D:  BCF    0A.4
009E:  GOTO   033
.................... #define bkbhit (next_in!=next_out)
.................... 
.................... BYTE bgetc() {
....................    BYTE c;
.................... 
....................    while(!bkbhit) ;
*
05DE:  MOVF   54,W
05DF:  SUBWF  53,W
05E0:  BTFSC  03.2
05E1:  GOTO   5DE
....................    c=buffer[next_out];
05E2:  MOVLW  33
05E3:  ADDWF  54,W
05E4:  MOVWF  04
05E5:  BCF    03.7
05E6:  MOVF   00,W
05E7:  MOVWF  76
....................    next_out=(next_out+1) % BUFFER_SIZE;
05E8:  MOVLW  01
05E9:  ADDWF  54,W
05EA:  MOVWF  7C
05EB:  CLRF   2B
05EC:  BTFSC  0B.7
05ED:  BSF    2B.7
05EE:  BCF    0B.7
05EF:  MOVF   7C,W
05F0:  BSF    03.5
05F1:  MOVWF  3F
05F2:  MOVLW  0B
05F3:  MOVWF  40
05F4:  BCF    03.5
05F5:  CALL   065
05F6:  BTFSC  2B.7
05F7:  BSF    0B.7
05F8:  MOVF   77,W
05F9:  MOVWF  54
....................    return(c);
05FA:  MOVF   76,W
05FB:  MOVWF  78
05FC:  BSF    0A.3
05FD:  BCF    0A.4
05FE:  GOTO   25E (RETURN)
.................... }
.................... 
.................... 
....................  unsigned char getkey()
.................... {
.................... 
.................... output_low(col1);output_high(col2);output_high(col3);output_high(col4);
*
03F7:  BSF    03.5
03F8:  BCF    06.4
03F9:  BCF    03.5
03FA:  BCF    06.4
03FB:  BSF    03.5
03FC:  BCF    06.5
03FD:  BCF    03.5
03FE:  BSF    06.5
03FF:  BSF    03.5
0400:  BCF    06.6
0401:  BCF    03.5
0402:  BSF    06.6
0403:  BSF    03.5
0404:  BCF    06.7
0405:  BCF    03.5
0406:  BSF    06.7
.................... if(!input(row1)) delay_ms(100); while (!input(row1)) return 'D';
0407:  BSF    03.5
0408:  BSF    06.0
0409:  BCF    03.5
040A:  BTFSC  06.0
040B:  GOTO   411
040C:  MOVLW  64
040D:  BSF    03.5
040E:  MOVWF  24
040F:  BCF    03.5
0410:  CALL   292
0411:  BSF    03.5
0412:  BSF    06.0
0413:  BCF    03.5
0414:  BTFSC  06.0
0415:  GOTO   41A
0416:  MOVLW  44
0417:  MOVWF  78
0418:  GOTO   569
0419:  GOTO   411
.................... if(!input(row2)) delay_ms(100); while (!input(row2)) return 'C';
041A:  BSF    03.5
041B:  BSF    06.1
041C:  BCF    03.5
041D:  BTFSC  06.1
041E:  GOTO   424
041F:  MOVLW  64
0420:  BSF    03.5
0421:  MOVWF  24
0422:  BCF    03.5
0423:  CALL   292
0424:  BSF    03.5
0425:  BSF    06.1
0426:  BCF    03.5
0427:  BTFSC  06.1
0428:  GOTO   42D
0429:  MOVLW  43
042A:  MOVWF  78
042B:  GOTO   569
042C:  GOTO   424
.................... if(!input(row3)) delay_ms(100); while (!input(row3)) return 'B';
042D:  BSF    03.5
042E:  BSF    06.2
042F:  BCF    03.5
0430:  BTFSC  06.2
0431:  GOTO   437
0432:  MOVLW  64
0433:  BSF    03.5
0434:  MOVWF  24
0435:  BCF    03.5
0436:  CALL   292
0437:  BSF    03.5
0438:  BSF    06.2
0439:  BCF    03.5
043A:  BTFSC  06.2
043B:  GOTO   440
043C:  MOVLW  42
043D:  MOVWF  78
043E:  GOTO   569
043F:  GOTO   437
.................... if(!input(row4)) delay_ms(100); while (!input(row4)) return 'A';
0440:  BSF    03.5
0441:  BSF    06.3
0442:  BCF    03.5
0443:  BTFSC  06.3
0444:  GOTO   44A
0445:  MOVLW  64
0446:  BSF    03.5
0447:  MOVWF  24
0448:  BCF    03.5
0449:  CALL   292
044A:  BSF    03.5
044B:  BSF    06.3
044C:  BCF    03.5
044D:  BTFSC  06.3
044E:  GOTO   453
044F:  MOVLW  41
0450:  MOVWF  78
0451:  GOTO   569
0452:  GOTO   44A
....................  
.................... output_high(col1);output_low(col2);output_high(col3);output_high(col4);
0453:  BSF    03.5
0454:  BCF    06.4
0455:  BCF    03.5
0456:  BSF    06.4
0457:  BSF    03.5
0458:  BCF    06.5
0459:  BCF    03.5
045A:  BCF    06.5
045B:  BSF    03.5
045C:  BCF    06.6
045D:  BCF    03.5
045E:  BSF    06.6
045F:  BSF    03.5
0460:  BCF    06.7
0461:  BCF    03.5
0462:  BSF    06.7
.................... if(!input(row1)) delay_ms(100); while (!input(row1)) return '#';
0463:  BSF    03.5
0464:  BSF    06.0
0465:  BCF    03.5
0466:  BTFSC  06.0
0467:  GOTO   46D
0468:  MOVLW  64
0469:  BSF    03.5
046A:  MOVWF  24
046B:  BCF    03.5
046C:  CALL   292
046D:  BSF    03.5
046E:  BSF    06.0
046F:  BCF    03.5
0470:  BTFSC  06.0
0471:  GOTO   476
0472:  MOVLW  23
0473:  MOVWF  78
0474:  GOTO   569
0475:  GOTO   46D
.................... if(!input(row2)) delay_ms(100); while (!input(row2)) return '9';
0476:  BSF    03.5
0477:  BSF    06.1
0478:  BCF    03.5
0479:  BTFSC  06.1
047A:  GOTO   480
047B:  MOVLW  64
047C:  BSF    03.5
047D:  MOVWF  24
047E:  BCF    03.5
047F:  CALL   292
0480:  BSF    03.5
0481:  BSF    06.1
0482:  BCF    03.5
0483:  BTFSC  06.1
0484:  GOTO   489
0485:  MOVLW  39
0486:  MOVWF  78
0487:  GOTO   569
0488:  GOTO   480
.................... if(!input(row3)) delay_ms(100); while (!input(row3)) return '6';
0489:  BSF    03.5
048A:  BSF    06.2
048B:  BCF    03.5
048C:  BTFSC  06.2
048D:  GOTO   493
048E:  MOVLW  64
048F:  BSF    03.5
0490:  MOVWF  24
0491:  BCF    03.5
0492:  CALL   292
0493:  BSF    03.5
0494:  BSF    06.2
0495:  BCF    03.5
0496:  BTFSC  06.2
0497:  GOTO   49C
0498:  MOVLW  36
0499:  MOVWF  78
049A:  GOTO   569
049B:  GOTO   493
.................... if(!input(row4)) delay_ms(100); while (!input(row4)) return '3';
049C:  BSF    03.5
049D:  BSF    06.3
049E:  BCF    03.5
049F:  BTFSC  06.3
04A0:  GOTO   4A6
04A1:  MOVLW  64
04A2:  BSF    03.5
04A3:  MOVWF  24
04A4:  BCF    03.5
04A5:  CALL   292
04A6:  BSF    03.5
04A7:  BSF    06.3
04A8:  BCF    03.5
04A9:  BTFSC  06.3
04AA:  GOTO   4AF
04AB:  MOVLW  33
04AC:  MOVWF  78
04AD:  GOTO   569
04AE:  GOTO   4A6
.................... 
.................... output_high(col1);output_high(col2);output_low(col3);output_high(col4);
04AF:  BSF    03.5
04B0:  BCF    06.4
04B1:  BCF    03.5
04B2:  BSF    06.4
04B3:  BSF    03.5
04B4:  BCF    06.5
04B5:  BCF    03.5
04B6:  BSF    06.5
04B7:  BSF    03.5
04B8:  BCF    06.6
04B9:  BCF    03.5
04BA:  BCF    06.6
04BB:  BSF    03.5
04BC:  BCF    06.7
04BD:  BCF    03.5
04BE:  BSF    06.7
.................... if(!input(row1)) delay_ms(100); while (!input(row1)) return '0';
04BF:  BSF    03.5
04C0:  BSF    06.0
04C1:  BCF    03.5
04C2:  BTFSC  06.0
04C3:  GOTO   4C9
04C4:  MOVLW  64
04C5:  BSF    03.5
04C6:  MOVWF  24
04C7:  BCF    03.5
04C8:  CALL   292
04C9:  BSF    03.5
04CA:  BSF    06.0
04CB:  BCF    03.5
04CC:  BTFSC  06.0
04CD:  GOTO   4D2
04CE:  MOVLW  30
04CF:  MOVWF  78
04D0:  GOTO   569
04D1:  GOTO   4C9
.................... if(!input(row2)) delay_ms(100); while (!input(row2)) return '8';
04D2:  BSF    03.5
04D3:  BSF    06.1
04D4:  BCF    03.5
04D5:  BTFSC  06.1
04D6:  GOTO   4DC
04D7:  MOVLW  64
04D8:  BSF    03.5
04D9:  MOVWF  24
04DA:  BCF    03.5
04DB:  CALL   292
04DC:  BSF    03.5
04DD:  BSF    06.1
04DE:  BCF    03.5
04DF:  BTFSC  06.1
04E0:  GOTO   4E5
04E1:  MOVLW  38
04E2:  MOVWF  78
04E3:  GOTO   569
04E4:  GOTO   4DC
.................... if(!input(row3)) delay_ms(100); while (!input(row3)) return '5';
04E5:  BSF    03.5
04E6:  BSF    06.2
04E7:  BCF    03.5
04E8:  BTFSC  06.2
04E9:  GOTO   4EF
04EA:  MOVLW  64
04EB:  BSF    03.5
04EC:  MOVWF  24
04ED:  BCF    03.5
04EE:  CALL   292
04EF:  BSF    03.5
04F0:  BSF    06.2
04F1:  BCF    03.5
04F2:  BTFSC  06.2
04F3:  GOTO   4F8
04F4:  MOVLW  35
04F5:  MOVWF  78
04F6:  GOTO   569
04F7:  GOTO   4EF
.................... if(!input(row4)) delay_ms(100); while (!input(row4)) return '2';
04F8:  BSF    03.5
04F9:  BSF    06.3
04FA:  BCF    03.5
04FB:  BTFSC  06.3
04FC:  GOTO   502
04FD:  MOVLW  64
04FE:  BSF    03.5
04FF:  MOVWF  24
0500:  BCF    03.5
0501:  CALL   292
0502:  BSF    03.5
0503:  BSF    06.3
0504:  BCF    03.5
0505:  BTFSC  06.3
0506:  GOTO   50B
0507:  MOVLW  32
0508:  MOVWF  78
0509:  GOTO   569
050A:  GOTO   502
.................... 
.................... output_high(col1);output_high(col2);output_high(col3);output_low(col4);
050B:  BSF    03.5
050C:  BCF    06.4
050D:  BCF    03.5
050E:  BSF    06.4
050F:  BSF    03.5
0510:  BCF    06.5
0511:  BCF    03.5
0512:  BSF    06.5
0513:  BSF    03.5
0514:  BCF    06.6
0515:  BCF    03.5
0516:  BSF    06.6
0517:  BSF    03.5
0518:  BCF    06.7
0519:  BCF    03.5
051A:  BCF    06.7
.................... if(!input(row1)) delay_ms(100); while (!input(row1)) return '*';
051B:  BSF    03.5
051C:  BSF    06.0
051D:  BCF    03.5
051E:  BTFSC  06.0
051F:  GOTO   525
0520:  MOVLW  64
0521:  BSF    03.5
0522:  MOVWF  24
0523:  BCF    03.5
0524:  CALL   292
0525:  BSF    03.5
0526:  BSF    06.0
0527:  BCF    03.5
0528:  BTFSC  06.0
0529:  GOTO   52E
052A:  MOVLW  2A
052B:  MOVWF  78
052C:  GOTO   569
052D:  GOTO   525
.................... if(!input(row2)) delay_ms(100); while (!input(row2)) return '7';
052E:  BSF    03.5
052F:  BSF    06.1
0530:  BCF    03.5
0531:  BTFSC  06.1
0532:  GOTO   538
0533:  MOVLW  64
0534:  BSF    03.5
0535:  MOVWF  24
0536:  BCF    03.5
0537:  CALL   292
0538:  BSF    03.5
0539:  BSF    06.1
053A:  BCF    03.5
053B:  BTFSC  06.1
053C:  GOTO   541
053D:  MOVLW  37
053E:  MOVWF  78
053F:  GOTO   569
0540:  GOTO   538
.................... if(!input(row3)) delay_ms(100); while (!input(row3)) return '4';
0541:  BSF    03.5
0542:  BSF    06.2
0543:  BCF    03.5
0544:  BTFSC  06.2
0545:  GOTO   54B
0546:  MOVLW  64
0547:  BSF    03.5
0548:  MOVWF  24
0549:  BCF    03.5
054A:  CALL   292
054B:  BSF    03.5
054C:  BSF    06.2
054D:  BCF    03.5
054E:  BTFSC  06.2
054F:  GOTO   554
0550:  MOVLW  34
0551:  MOVWF  78
0552:  GOTO   569
0553:  GOTO   54B
.................... if(!input(row4)) delay_ms(100); while (!input(row4)) return '1';
0554:  BSF    03.5
0555:  BSF    06.3
0556:  BCF    03.5
0557:  BTFSC  06.3
0558:  GOTO   55E
0559:  MOVLW  64
055A:  BSF    03.5
055B:  MOVWF  24
055C:  BCF    03.5
055D:  CALL   292
055E:  BSF    03.5
055F:  BSF    06.3
0560:  BCF    03.5
0561:  BTFSC  06.3
0562:  GOTO   567
0563:  MOVLW  31
0564:  MOVWF  78
0565:  GOTO   569
0566:  GOTO   55E
....................  
.................... 
....................  
....................  return 'n';
0567:  MOVLW  6E
0568:  MOVWF  78
0569:  RETURN
....................  
.................... }
.................... 
.................... 
.................... int1 kt_the (char UID[])
.................... {  int i;
....................    for (int j=6;j<=20;j=j+5)
*
07A5:  MOVLW  06
07A6:  MOVWF  7B
07A7:  MOVF   7B,W
07A8:  SUBLW  14
07A9:  BTFSS  03.0
07AA:  GOTO   7D3
....................    {
....................       for ( i=0;i<5;i++)
07AB:  CLRF   76
07AC:  MOVF   76,W
07AD:  SUBLW  04
07AE:  BTFSS  03.0
07AF:  GOTO   7CC
....................       {
....................          if (read_eeprom(i+j)!= UID[i])
07B0:  MOVF   7B,W
07B1:  ADDWF  76,W
07B2:  MOVWF  7C
07B3:  MOVF   7C,W
07B4:  BSF    03.6
07B5:  MOVWF  0D
07B6:  BSF    03.5
07B7:  BCF    0C.7
07B8:  BSF    0C.0
07B9:  BCF    03.5
07BA:  MOVF   0C,W
07BB:  MOVWF  7C
07BC:  MOVF   76,W
07BD:  ADDWF  74,W
07BE:  MOVWF  04
07BF:  BCF    03.7
07C0:  BTFSC  75.0
07C1:  BSF    03.7
07C2:  MOVF   00,W
07C3:  SUBWF  7C,W
07C4:  BTFSC  03.2
07C5:  GOTO   7C9
....................             break;
07C6:  BCF    03.6
07C7:  GOTO   7CC
07C8:  BSF    03.6
07C9:  INCF   76,F
07CA:  BCF    03.6
07CB:  GOTO   7AC
....................       }   
....................       if (i==5) 
07CC:  MOVF   76,W
07CD:  SUBLW  05
07CE:  BTFSC  03.2
....................          break;
07CF:  GOTO   7D3
07D0:  MOVLW  05
07D1:  ADDWF  7B,F
07D2:  GOTO   7A7
....................    } 
....................    if (i==5)
07D3:  MOVF   76,W
07D4:  SUBLW  05
07D5:  BTFSS  03.2
07D6:  GOTO   7DB
....................    return 1;
07D7:  MOVLW  01
07D8:  MOVWF  78
07D9:  GOTO   7DD
07DA:  GOTO   7DD
....................    else 
....................    return 0;
07DB:  MOVLW  00
07DC:  MOVWF  78
07DD:  RETURN
....................    
.................... }
.................... 
.................... void them_the(char UID[])
.................... {
....................    int i,j;
....................    for ( j=6;j<=20;j=j+5)
*
0902:  MOVLW  06
0903:  MOVWF  7B
0904:  MOVF   7B,W
0905:  SUBLW  14
0906:  BTFSS  03.0
0907:  GOTO   14B
....................       {
....................          for ( i=0;i<5;i++)
0908:  CLRF   76
0909:  MOVF   76,W
090A:  SUBLW  04
090B:  BTFSS  03.0
090C:  GOTO   144
....................          {
....................             if(read_eeprom(i+j)==0xFF)
090D:  MOVF   7B,W
090E:  ADDWF  76,W
090F:  MOVWF  7C
0910:  MOVF   7C,W
0911:  BSF    03.6
0912:  MOVWF  0D
0913:  BSF    03.5
0914:  BCF    0C.7
0915:  BSF    0C.0
0916:  BCF    03.5
0917:  MOVF   0C,W
0918:  SUBLW  FF
0919:  BTFSS  03.2
091A:  GOTO   140
....................             {
....................                write_eeprom(i+j, UID[i]);
091B:  MOVF   7B,W
091C:  ADDWF  76,W
091D:  MOVWF  7C
091E:  MOVF   76,W
091F:  ADDWF  74,W
0920:  MOVWF  04
0921:  BCF    03.7
0922:  BTFSC  75.0
0923:  BSF    03.7
0924:  MOVF   00,W
0925:  MOVWF  7D
0926:  BCF    03.6
0927:  MOVF   0B,W
0928:  MOVWF  77
0929:  BCF    0B.7
092A:  MOVF   7C,W
092B:  BSF    03.6
092C:  MOVWF  0D
092D:  MOVF   7D,W
092E:  MOVWF  0C
092F:  BSF    03.5
0930:  BCF    0C.7
0931:  BSF    0C.2
0932:  MOVLW  55
0933:  MOVWF  0D
0934:  MOVLW  AA
0935:  MOVWF  0D
0936:  BSF    0C.1
0937:  BTFSC  0C.1
0938:  GOTO   137
0939:  BCF    0C.2
093A:  MOVF   77,W
093B:  BCF    03.5
093C:  BCF    03.6
093D:  IORWF  0B,F
....................             }
093E:  GOTO   142
093F:  BSF    03.6
....................             else
....................                break;
0940:  BCF    03.6
0941:  GOTO   144
0942:  INCF   76,F
0943:  GOTO   109
....................          }
....................          if (i==5) 
0944:  MOVF   76,W
0945:  SUBLW  05
0946:  BTFSC  03.2
....................             break;
0947:  GOTO   14B
0948:  MOVLW  05
0949:  ADDWF  7B,F
094A:  GOTO   104
....................       }
094B:  BSF    0A.3
094C:  BCF    0A.4
094D:  GOTO   5C6 (RETURN)
.................... }
.................... 
.................... void xoa_the(char UID[])
.................... {
....................     int i,j;
....................    for (j=6;j<=20;j=j+5)
094E:  MOVLW  06
094F:  MOVWF  7B
0950:  MOVF   7B,W
0951:  SUBLW  14
0952:  BTFSS  03.0
0953:  GOTO   1A1
....................    {
....................       for ( i=0;i<5;i++)
0954:  CLRF   76
0955:  MOVF   76,W
0956:  SUBLW  04
0957:  BTFSS  03.0
0958:  GOTO   175
....................       {
....................          if (read_eeprom(i+j)!= UID[i])
0959:  MOVF   7B,W
095A:  ADDWF  76,W
095B:  MOVWF  7C
095C:  MOVF   7C,W
095D:  BSF    03.6
095E:  MOVWF  0D
095F:  BSF    03.5
0960:  BCF    0C.7
0961:  BSF    0C.0
0962:  BCF    03.5
0963:  MOVF   0C,W
0964:  MOVWF  7C
0965:  MOVF   76,W
0966:  ADDWF  74,W
0967:  MOVWF  04
0968:  BCF    03.7
0969:  BTFSC  75.0
096A:  BSF    03.7
096B:  MOVF   00,W
096C:  SUBWF  7C,W
096D:  BTFSC  03.2
096E:  GOTO   172
....................             break;
096F:  BCF    03.6
0970:  GOTO   175
0971:  BSF    03.6
0972:  INCF   76,F
0973:  BCF    03.6
0974:  GOTO   155
....................       }   
....................       if (i==5)
0975:  MOVF   76,W
0976:  SUBLW  05
0977:  BTFSS  03.2
0978:  GOTO   19A
....................       {
....................          for (i=0;i<5;i++)
0979:  CLRF   76
097A:  MOVF   76,W
097B:  SUBLW  04
097C:  BTFSS  03.0
097D:  GOTO   19A
....................             write_eeprom(i+j, 0xFF);
097E:  MOVF   7B,W
097F:  ADDWF  76,W
0980:  MOVWF  7C
0981:  MOVF   0B,W
0982:  MOVWF  77
0983:  BCF    0B.7
0984:  MOVF   7C,W
0985:  BSF    03.6
0986:  MOVWF  0D
0987:  MOVLW  FF
0988:  MOVWF  0C
0989:  BSF    03.5
098A:  BCF    0C.7
098B:  BSF    0C.2
098C:  MOVLW  55
098D:  MOVWF  0D
098E:  MOVLW  AA
098F:  MOVWF  0D
0990:  BSF    0C.1
0991:  BTFSC  0C.1
0992:  GOTO   191
0993:  BCF    0C.2
0994:  MOVF   77,W
0995:  BCF    03.5
0996:  BCF    03.6
0997:  IORWF  0B,F
0998:  INCF   76,F
0999:  GOTO   17A
....................       }
....................       if(i==5)
099A:  MOVF   76,W
099B:  SUBLW  05
099C:  BTFSC  03.2
....................          break;
099D:  GOTO   1A1
099E:  MOVLW  05
099F:  ADDWF  7B,F
09A0:  GOTO   150
....................    }
09A1:  BSF    0A.3
09A2:  BCF    0A.4
09A3:  GOTO   600 (RETURN)
.................... }
.................... 
.................... void bipbip(unsigned int8 hoi,unsigned int8 tieng) 
.................... { 
....................    unsigned int8 i, j;
....................    for(i = 0; i < hoi; i ++){
*
0800:  BSF    03.5
0801:  CLRF   20
0802:  MOVF   7D,W
0803:  SUBWF  20,W
0804:  BTFSC  03.0
0805:  GOTO   02D
....................       for(j = 0; j < tieng; j ++){
0806:  CLRF   21
0807:  MOVF   7E,W
0808:  SUBWF  21,W
0809:  BTFSC  03.0
080A:  GOTO   01C
....................          output_high(pin_c0);
080B:  BCF    03.5
080C:  BCF    2C.0
080D:  MOVF   2C,W
080E:  BSF    03.5
080F:  MOVWF  07
0810:  BCF    03.5
0811:  BSF    07.0
....................          delay_ms(1);
0812:  MOVLW  01
0813:  BSF    03.5
0814:  MOVWF  24
0815:  BCF    0A.3
0816:  BCF    03.5
0817:  CALL   292
0818:  BSF    0A.3
0819:  BSF    03.5
081A:  INCF   21,F
081B:  GOTO   007
....................       }
....................       output_low(pin_c0);
081C:  BCF    03.5
081D:  BCF    2C.0
081E:  MOVF   2C,W
081F:  BSF    03.5
0820:  MOVWF  07
0821:  BCF    03.5
0822:  BCF    07.0
....................       delay_ms(10);
0823:  MOVLW  0A
0824:  BSF    03.5
0825:  MOVWF  24
0826:  BCF    0A.3
0827:  BCF    03.5
0828:  CALL   292
0829:  BSF    0A.3
082A:  BSF    03.5
082B:  INCF   20,F
082C:  GOTO   002
....................    }
082D:  BCF    03.5
082E:  RETURN
.................... }
.................... 
.................... int1 door=0;
.................... char mk1,mk2,mk3,mk4;
.................... 
.................... void kt_pass(void)
082F:  CLRF   7C
.................... {
....................    int e,f,g,h,i=0;
....................    for(;i<=2;i++)
0830:  MOVF   7C,W
0831:  SUBLW  02
0832:  BTFSS  03.0
0833:  GOTO   0D9
....................    {
....................    do
....................    {
....................    do
....................    {
....................       do
....................       {
....................          do
....................          {
....................                lcd_putc('\f');
0834:  MOVLW  0C
0835:  BSF    03.5
0836:  MOVWF  23
0837:  BCF    0A.3
0838:  BCF    03.5
0839:  CALL   36B
083A:  BSF    0A.3
....................                lcd_gotoxy(1,1);
083B:  MOVLW  01
083C:  BSF    03.5
083D:  MOVWF  24
083E:  MOVWF  25
083F:  BCF    0A.3
0840:  BCF    03.5
0841:  CALL   357
0842:  BSF    0A.3
....................                lcd_putc("PASS:");
0843:  MOVLW  9F
0844:  BSF    03.6
0845:  MOVWF  0D
0846:  MOVLW  00
0847:  MOVWF  0F
0848:  BCF    0A.3
0849:  BCF    03.6
084A:  CALL   56A
084B:  BSF    0A.3
....................                lcd_gotoxy(4,2);
084C:  MOVLW  04
084D:  BSF    03.5
084E:  MOVWF  24
084F:  MOVLW  02
0850:  MOVWF  25
0851:  BCF    0A.3
0852:  BCF    03.5
0853:  CALL   357
0854:  BSF    0A.3
....................             do
....................             {
....................                getkey();
0855:  BCF    0A.3
0856:  CALL   3F7
0857:  BSF    0A.3
....................                e=getkey();
0858:  BCF    0A.3
0859:  CALL   3F7
085A:  BSF    0A.3
085B:  MOVF   78,W
085C:  MOVWF  74
....................             }
....................             while (e=='n');
085D:  MOVF   74,W
085E:  SUBLW  6E
085F:  BTFSC  03.2
0860:  GOTO   055
....................                lcd_putc(e);
0861:  MOVF   74,W
0862:  BSF    03.5
0863:  MOVWF  23
0864:  BCF    0A.3
0865:  BCF    03.5
0866:  CALL   36B
0867:  BSF    0A.3
....................             do
....................             {
....................                getkey();
0868:  BCF    0A.3
0869:  CALL   3F7
086A:  BSF    0A.3
....................                f=getkey();
086B:  BCF    0A.3
086C:  CALL   3F7
086D:  BSF    0A.3
086E:  MOVF   78,W
086F:  MOVWF  75
....................             }
....................             while (f=='n');
0870:  MOVF   75,W
0871:  SUBLW  6E
0872:  BTFSC  03.2
0873:  GOTO   068
....................                lcd_putc(f);
0874:  MOVF   75,W
0875:  BSF    03.5
0876:  MOVWF  23
0877:  BCF    0A.3
0878:  BCF    03.5
0879:  CALL   36B
087A:  BSF    0A.3
....................          }
....................          while (f=='#');
087B:  MOVF   75,W
087C:  SUBLW  23
087D:  BTFSC  03.2
087E:  GOTO   034
....................          do
....................          {
....................             getkey();
087F:  BCF    0A.3
0880:  CALL   3F7
0881:  BSF    0A.3
....................             g=getkey();
0882:  BCF    0A.3
0883:  CALL   3F7
0884:  BSF    0A.3
0885:  MOVF   78,W
0886:  MOVWF  76
....................          }
....................          while (g=='n');
0887:  MOVF   76,W
0888:  SUBLW  6E
0889:  BTFSC  03.2
088A:  GOTO   07F
....................             lcd_putc(g);
088B:  MOVF   76,W
088C:  BSF    03.5
088D:  MOVWF  23
088E:  BCF    0A.3
088F:  BCF    03.5
0890:  CALL   36B
0891:  BSF    0A.3
....................       }
....................       while (g=='#');
0892:  MOVF   76,W
0893:  SUBLW  23
0894:  BTFSC  03.2
0895:  GOTO   034
....................       do
....................       {
....................          getkey();
0896:  BCF    0A.3
0897:  CALL   3F7
0898:  BSF    0A.3
....................          h=getkey();
0899:  BCF    0A.3
089A:  CALL   3F7
089B:  BSF    0A.3
089C:  MOVF   78,W
089D:  MOVWF  7B
....................       }
....................       while (h=='n');
089E:  MOVF   7B,W
089F:  SUBLW  6E
08A0:  BTFSC  03.2
08A1:  GOTO   096
....................          lcd_putc(h);
08A2:  MOVF   7B,W
08A3:  BSF    03.5
08A4:  MOVWF  23
08A5:  BCF    0A.3
08A6:  BCF    03.5
08A7:  CALL   36B
08A8:  BSF    0A.3
....................          
....................    }
....................    while (f=='#');
08A9:  MOVF   75,W
08AA:  SUBLW  23
08AB:  BTFSC  03.2
08AC:  GOTO   034
....................    // Nhan enter//
....................           do
....................       {
....................          getkey();
08AD:  BCF    0A.3
08AE:  CALL   3F7
08AF:  BSF    0A.3
....................          
....................       }
....................       while ( getkey()!='*' && getkey()!='#');
08B0:  BCF    0A.3
08B1:  CALL   3F7
08B2:  BSF    0A.3
08B3:  MOVF   78,W
08B4:  SUBLW  2A
08B5:  BTFSC  03.2
08B6:  GOTO   0BE
08B7:  BCF    0A.3
08B8:  CALL   3F7
08B9:  BSF    0A.3
08BA:  MOVF   78,W
08BB:  SUBLW  23
08BC:  BTFSS  03.2
08BD:  GOTO   0AD
....................          //
....................   }
....................    while (getkey()=='#');
08BE:  BCF    0A.3
08BF:  CALL   3F7
08C0:  BSF    0A.3
08C1:  MOVF   78,W
08C2:  SUBLW  23
08C3:  BTFSC  03.2
08C4:  GOTO   034
....................   if (e==mk1 && f==mk2 && g==mk3 && h==mk4)
08C5:  MOVF   57,W
08C6:  SUBWF  74,W
08C7:  BTFSS  03.2
08C8:  GOTO   0D7
08C9:  MOVF   58,W
08CA:  SUBWF  75,W
08CB:  BTFSS  03.2
08CC:  GOTO   0D7
08CD:  MOVF   59,W
08CE:  SUBWF  76,W
08CF:  BTFSS  03.2
08D0:  GOTO   0D7
08D1:  MOVF   5A,W
08D2:  SUBWF  7B,W
08D3:  BTFSS  03.2
08D4:  GOTO   0D7
....................       {
....................       door=1;
08D5:  BSF    56.0
....................       break;
08D6:  GOTO   0D9
....................       }
08D7:  INCF   7C,F
08D8:  GOTO   030
....................    }
....................    if (i==3)
08D9:  MOVF   7C,W
08DA:  SUBLW  03
08DB:  BTFSS  03.2
08DC:  GOTO   101
....................    {
....................       lcd_putc('\f');
08DD:  MOVLW  0C
08DE:  BSF    03.5
08DF:  MOVWF  23
08E0:  BCF    0A.3
08E1:  BCF    03.5
08E2:  CALL   36B
08E3:  BSF    0A.3
....................       do 
....................       {  
....................          lcd_gotoxy(2,1);
08E4:  MOVLW  02
08E5:  BSF    03.5
08E6:  MOVWF  24
08E7:  MOVLW  01
08E8:  MOVWF  25
08E9:  BCF    0A.3
08EA:  BCF    03.5
08EB:  CALL   357
08EC:  BSF    0A.3
....................          lcd_putc("WRONG PASSWORD");
08ED:  MOVLW  A2
08EE:  BSF    03.6
08EF:  MOVWF  0D
08F0:  MOVLW  00
08F1:  MOVWF  0F
08F2:  BCF    0A.3
08F3:  BCF    03.6
08F4:  CALL   56A
08F5:  BSF    0A.3
....................           bipbip(10,10);
08F6:  MOVLW  0A
08F7:  MOVWF  7D
08F8:  MOVWF  7E
08F9:  CALL   000
....................       }
....................       while (getkey()!='#');
08FA:  BCF    0A.3
08FB:  CALL   3F7
08FC:  BSF    0A.3
08FD:  MOVF   78,W
08FE:  SUBLW  23
08FF:  BTFSS  03.2
0900:  GOTO   0E4
....................    }
0901:  RETURN
.................... }
.................... 
.................... 
.................... void main()
*
09A4:  MOVF   03,W
09A5:  ANDLW  1F
09A6:  MOVWF  03
09A7:  MOVLW  FF
09A8:  MOVWF  2C
09A9:  MOVLW  0A
09AA:  BSF    03.5
09AB:  MOVWF  19
09AC:  MOVLW  A6
09AD:  MOVWF  18
09AE:  MOVLW  90
09AF:  BCF    03.5
09B0:  MOVWF  18
09B1:  CLRF   53
09B2:  CLRF   54
09B3:  BCF    56.0
09B4:  CLRF   5C
09B5:  CLRF   5B
09B6:  BSF    03.5
09B7:  BSF    1F.0
09B8:  BSF    1F.1
09B9:  BSF    1F.2
09BA:  BCF    1F.3
09BB:  MOVLW  07
09BC:  MOVWF  1C
09BD:  BCF    03.7
.................... {
.................... setup_timer_1(t1_internal|t1_div_by_8);
*
09C1:  MOVLW  B5
09C2:  MOVWF  10
.................... enable_interrupts(INT_TIMER1);
09C3:  BSF    03.5
09C4:  BSF    0C.0
.................... enable_interrupts(INT_RDA);
09C5:  BSF    0C.5
.................... enable_interrupts(GLOBAL);
09C6:  MOVLW  C0
09C7:  BCF    03.5
09C8:  IORWF  0B,F
.................... set_timer1(3036);
09C9:  CLRF   0E
09CA:  MOVLW  0B
09CB:  MOVWF  0F
09CC:  MOVLW  DC
09CD:  MOVWF  0E
09CE:  NOP
.................... MFRC522_Init ();
09CF:  BCF    0A.3
09D0:  GOTO   222
09D1:  BSF    0A.3
.................... lcd_init(); 
09D2:  BCF    0A.3
09D3:  GOTO   30F
09D4:  BSF    0A.3
.................... lcd_putc('\f');
09D5:  MOVLW  0C
09D6:  BSF    03.5
09D7:  MOVWF  23
09D8:  BCF    0A.3
09D9:  BCF    03.5
09DA:  CALL   36B
09DB:  BSF    0A.3
.................... //!lcd_putc("Connecting Wifi");
.................... //!otp_init();
.................... //!
.................... int a='1',b='1',c='1',d='1',m;
.................... CHAR UID[6];
.................... UNSIGNED int TagType;  
.................... char str [10];
09DC:  MOVLW  31
09DD:  MOVWF  5D
09DE:  MOVWF  5E
09DF:  MOVWF  5F
09E0:  MOVWF  60
.................... //!   int16 adc_value, vout_value;
.................... //!   float voltage_value, current_value; 
.................... //!   setup_adc_ports( AN0 );
.................... //!   setup_adc(ADC_CLOCK_INTERNAL );  
.................... //!   set_adc_channel( 0 );
.................... //!///
.................... delay_ms(3000);
09E1:  MOVLW  0C
09E2:  MOVWF  74
09E3:  MOVLW  FA
09E4:  BSF    03.5
09E5:  MOVWF  24
09E6:  BCF    0A.3
09E7:  BCF    03.5
09E8:  CALL   292
09E9:  BSF    0A.3
09EA:  DECFSZ 74,F
09EB:  GOTO   1E3
.................... 
.................... 
....................    
.................... 
.................... ///
....................    while(TRUE)
....................    {
.................... door = 0;
09EC:  BCF    56.0
.................... output_low(PIN_D3);
09ED:  BSF    03.5
09EE:  BCF    08.3
09EF:  BCF    03.5
09F0:  BCF    08.3
....................  printf("CLOSE");
09F1:  MOVLW  AA
09F2:  BSF    03.6
09F3:  MOVWF  0D
09F4:  MOVLW  00
09F5:  MOVWF  0F
09F6:  BCF    0A.3
09F7:  BCF    03.6
09F8:  CALL   3A5
09F9:  BSF    0A.3
.................... 
.................... lcd_putc('\f');
09FA:  MOVLW  0C
09FB:  BSF    03.5
09FC:  MOVWF  23
09FD:  BCF    0A.3
09FE:  BCF    03.5
09FF:  CALL   36B
0A00:  BSF    0A.3
.................... //!  do
.................... //!       {   
.................... //!         
.................... //!          output_low(PIN_D3);
.................... //!           delay_ms(500);
.................... //!           adc_value = read_adc();
.................... //!            lcd_gotoxy(1,1);
.................... //!              lcd_putc("CUA CHUA DONG");
.................... //!        }
.................... //!        while (adc_value<510);
.................... do
....................    {  
....................         door = 0;
0A01:  BCF    56.0
....................         output_low(PIN_D3);
0A02:  BSF    03.5
0A03:  BCF    08.3
0A04:  BCF    03.5
0A05:  BCF    08.3
....................        
....................    do   
....................    {
....................    
....................     lcd_putc('\f');  
0A06:  MOVLW  0C
0A07:  BSF    03.5
0A08:  MOVWF  23
0A09:  BCF    0A.3
0A0A:  BCF    03.5
0A0B:  CALL   36B
0A0C:  BSF    0A.3
....................       getkey();
0A0D:  BCF    0A.3
0A0E:  CALL   3F7
0A0F:  BSF    0A.3
....................       m=getkey();
0A10:  BCF    0A.3
0A11:  CALL   3F7
0A12:  BSF    0A.3
0A13:  MOVF   78,W
0A14:  MOVWF  61
.................... //!      lcd_gotoxy(4,1);
....................       //Xac nhan dng//
.................... //!      delay_us(100);
.................... //!      adc_value = read_adc();
....................    //!      if( adc_value>495)
....................    //!      {
....................    //!         printf("DONG");
....................    //!      }
.................... //!    lcd_gotoxy(3,2);
.................... //!    printf(lcd_putc, "%.2f  ",  (float)adc_value);
....................     //
....................    //!   lcd_putc("\f  HELLOOOO");
.................... //!      lcd_gotoxy(1,2);
.................... //!      lcd_putc(" press 1 to enter pass");
.................... 
.................... 
.................... // NT CHUNG///
....................    if (input(PIN_A2)==1)
0A15:  BSF    03.5
0A16:  BSF    05.2
0A17:  BCF    03.5
0A18:  BTFSS  05.2
0A19:  GOTO   240
....................    {
....................    printf("BELL");
0A1A:  MOVLW  AD
0A1B:  BSF    03.6
0A1C:  MOVWF  0D
0A1D:  MOVLW  00
0A1E:  MOVWF  0F
0A1F:  BCF    0A.3
0A20:  BCF    03.6
0A21:  CALL   3A5
0A22:  BSF    0A.3
....................     lcd_gotoxy(3,2);
0A23:  MOVLW  03
0A24:  BSF    03.5
0A25:  MOVWF  24
0A26:  MOVLW  02
0A27:  MOVWF  25
0A28:  BCF    0A.3
0A29:  BCF    03.5
0A2A:  CALL   357
0A2B:  BSF    0A.3
....................     lcd_putc("CHUONG");
0A2C:  MOVLW  B0
0A2D:  BSF    03.6
0A2E:  MOVWF  0D
0A2F:  MOVLW  00
0A30:  MOVWF  0F
0A31:  BCF    0A.3
0A32:  BCF    03.6
0A33:  CALL   56A
0A34:  BSF    0A.3
....................    delay_ms(2000);
0A35:  MOVLW  08
0A36:  MOVWF  74
0A37:  MOVLW  FA
0A38:  BSF    03.5
0A39:  MOVWF  24
0A3A:  BCF    0A.3
0A3B:  BCF    03.5
0A3C:  CALL   292
0A3D:  BSF    0A.3
0A3E:  DECFSZ 74,F
0A3F:  GOTO   237
....................    }
.................... ///
....................  if (input(PIN_A0)==1)
0A40:  BSF    03.5
0A41:  BSF    05.0
0A42:  BCF    03.5
0A43:  BTFSC  05.0
....................  door=1;
0A44:  BSF    56.0
.................... 
.................... 
....................    //ESP32//
....................    
....................          if (bkbhit)
0A45:  MOVF   54,W
0A46:  SUBWF  53,W
0A47:  BTFSC  03.2
0A48:  GOTO   274
....................          {
....................           for (int i=0; i<11;i++)
0A49:  CLRF   73
0A4A:  MOVF   73,W
0A4B:  SUBLW  0A
0A4C:  BTFSS  03.0
0A4D:  GOTO   274
....................          {
....................              if (bkbhit)
0A4E:  MOVF   54,W
0A4F:  SUBWF  53,W
0A50:  BTFSC  03.2
0A51:  GOTO   272
....................          {
....................         
....................             str[i]=bgetc();
0A52:  MOVLW  69
0A53:  ADDWF  73,W
0A54:  MOVWF  78
0A55:  CLRF   7A
0A56:  BTFSC  03.0
0A57:  INCF   7A,F
0A58:  MOVF   78,W
0A59:  MOVWF  74
0A5A:  MOVF   7A,W
0A5B:  MOVWF  75
0A5C:  BCF    0A.3
0A5D:  GOTO   5DE
0A5E:  BSF    0A.3
0A5F:  MOVF   74,W
0A60:  MOVWF  04
0A61:  BCF    03.7
0A62:  BTFSC  75.0
0A63:  BSF    03.7
0A64:  MOVF   78,W
0A65:  MOVWF  00
....................             
....................    //!         printf(str[i]);
....................             
....................             lcd_putc(str[i]);
0A66:  MOVLW  69
0A67:  ADDWF  73,W
0A68:  MOVWF  04
0A69:  BCF    03.7
0A6A:  MOVF   00,W
0A6B:  MOVWF  74
0A6C:  BSF    03.5
0A6D:  MOVWF  23
0A6E:  BCF    0A.3
0A6F:  BCF    03.5
0A70:  CALL   36B
0A71:  BSF    0A.3
....................             }
0A72:  INCF   73,F
0A73:  GOTO   24A
....................       }
....................    }
....................           lcd_gotoxy(1,1);
0A74:  MOVLW  01
0A75:  BSF    03.5
0A76:  MOVWF  24
0A77:  MOVWF  25
0A78:  BCF    0A.3
0A79:  BCF    03.5
0A7A:  CALL   357
0A7B:  BSF    0A.3
....................           lcd_putc(str[0]); lcd_putc(str[1]); lcd_putc(str[2]); lcd_putc(str[3]);lcd_putc(str[4]);
0A7C:  MOVF   69,W
0A7D:  BSF    03.5
0A7E:  MOVWF  23
0A7F:  BCF    0A.3
0A80:  BCF    03.5
0A81:  CALL   36B
0A82:  BSF    0A.3
0A83:  MOVF   6A,W
0A84:  BSF    03.5
0A85:  MOVWF  23
0A86:  BCF    0A.3
0A87:  BCF    03.5
0A88:  CALL   36B
0A89:  BSF    0A.3
0A8A:  MOVF   6B,W
0A8B:  BSF    03.5
0A8C:  MOVWF  23
0A8D:  BCF    0A.3
0A8E:  BCF    03.5
0A8F:  CALL   36B
0A90:  BSF    0A.3
0A91:  MOVF   6C,W
0A92:  BSF    03.5
0A93:  MOVWF  23
0A94:  BCF    0A.3
0A95:  BCF    03.5
0A96:  CALL   36B
0A97:  BSF    0A.3
0A98:  MOVF   6D,W
0A99:  BSF    03.5
0A9A:  MOVWF  23
0A9B:  BCF    0A.3
0A9C:  BCF    03.5
0A9D:  CALL   36B
0A9E:  BSF    0A.3
....................           lcd_putc(str[5]); lcd_putc(str[6]); lcd_putc(str[7]);lcd_putc(str[8]);lcd_putc(str[9]);lcd_putc(str[10]);
0A9F:  MOVF   6E,W
0AA0:  BSF    03.5
0AA1:  MOVWF  23
0AA2:  BCF    0A.3
0AA3:  BCF    03.5
0AA4:  CALL   36B
0AA5:  BSF    0A.3
0AA6:  MOVF   6F,W
0AA7:  BSF    03.5
0AA8:  MOVWF  23
0AA9:  BCF    0A.3
0AAA:  BCF    03.5
0AAB:  CALL   36B
0AAC:  BSF    0A.3
0AAD:  MOVF   70,W
0AAE:  BSF    03.5
0AAF:  MOVWF  23
0AB0:  BCF    0A.3
0AB1:  BCF    03.5
0AB2:  CALL   36B
0AB3:  BSF    0A.3
0AB4:  MOVF   71,W
0AB5:  BSF    03.5
0AB6:  MOVWF  23
0AB7:  BCF    0A.3
0AB8:  BCF    03.5
0AB9:  CALL   36B
0ABA:  BSF    0A.3
0ABB:  MOVF   72,W
0ABC:  BSF    03.5
0ABD:  MOVWF  23
0ABE:  BCF    0A.3
0ABF:  BCF    03.5
0AC0:  CALL   36B
0AC1:  BSF    0A.3
0AC2:  MOVF   73,W
0AC3:  BSF    03.5
0AC4:  MOVWF  23
0AC5:  BCF    0A.3
0AC6:  BCF    03.5
0AC7:  CALL   36B
0AC8:  BSF    0A.3
.................... //!        
....................       if(str[1]>=0x30&&str[1]<=0x39&&str[2]>=0x30&&str[2]<=0x39)
0AC9:  MOVF   6A,W
0ACA:  SUBLW  2F
0ACB:  BTFSC  03.0
0ACC:  GOTO   2E1
0ACD:  MOVF   6A,W
0ACE:  SUBLW  39
0ACF:  BTFSS  03.0
0AD0:  GOTO   2E1
0AD1:  MOVF   6B,W
0AD2:  SUBLW  2F
0AD3:  BTFSC  03.0
0AD4:  GOTO   2E1
0AD5:  MOVF   6B,W
0AD6:  SUBLW  39
0AD7:  BTFSS  03.0
0AD8:  GOTO   2E1
....................       {
....................          mk1=str[1];mk2=str[2];mk3=str[3];mk4=str[4];
0AD9:  MOVF   6A,W
0ADA:  MOVWF  57
0ADB:  MOVF   6B,W
0ADC:  MOVWF  58
0ADD:  MOVF   6C,W
0ADE:  MOVWF  59
0ADF:  MOVF   6D,W
0AE0:  MOVWF  5A
....................       }
....................       
....................       if(str[5]=='O'&&str[6]=='P'&&str[7]=='E'&&str[8]=='N'&&str[9]=='N')
0AE1:  MOVF   6E,W
0AE2:  SUBLW  4F
0AE3:  BTFSS  03.2
0AE4:  GOTO   30A
0AE5:  MOVF   6F,W
0AE6:  SUBLW  50
0AE7:  BTFSS  03.2
0AE8:  GOTO   30A
0AE9:  MOVF   70,W
0AEA:  SUBLW  45
0AEB:  BTFSS  03.2
0AEC:  GOTO   30A
0AED:  MOVF   71,W
0AEE:  SUBLW  4E
0AEF:  BTFSS  03.2
0AF0:  GOTO   30A
0AF1:  MOVF   72,W
0AF2:  SUBLW  4E
0AF3:  BTFSS  03.2
0AF4:  GOTO   30A
....................       {
....................          door=1;
0AF5:  BSF    56.0
....................          str[5]=='C'&&str[6]=='L'&&str[7]=='O'&&str[8]=='S'&&str[9]=='E';
0AF6:  MOVF   6E,W
0AF7:  SUBLW  43
0AF8:  BTFSS  03.2
0AF9:  GOTO   309
0AFA:  MOVF   6F,W
0AFB:  SUBLW  4C
0AFC:  BTFSS  03.2
0AFD:  GOTO   309
0AFE:  MOVF   70,W
0AFF:  SUBLW  4F
0B00:  BTFSS  03.2
0B01:  GOTO   309
0B02:  MOVF   71,W
0B03:  SUBLW  53
0B04:  BTFSS  03.2
0B05:  GOTO   309
0B06:  MOVF   72,W
0B07:  SUBLW  45
0B08:  BTFSS  03.2
0B09:  MOVLW  00
....................       }
....................    
....................    //
....................    
....................    IF (MFRC522_isCard (&TagType)) //Check any card
0B0A:  CLRF   75
0B0B:  MOVLW  68
0B0C:  MOVWF  74
0B0D:  BCF    0A.3
0B0E:  CALL   6FD
0B0F:  BSF    0A.3
0B10:  MOVF   78,F
0B11:  BTFSC  03.2
0B12:  GOTO   387
....................          {                                           
....................             //Read ID 
....................             IF (MFRC522_ReadCardSerial (&UID))             
0B13:  CLRF   75
0B14:  MOVLW  62
0B15:  MOVWF  74
0B16:  BCF    0A.3
0B17:  CALL   73A
0B18:  BSF    0A.3
0B19:  MOVF   78,F
0B1A:  BTFSC  03.2
0B1B:  GOTO   387
....................             {
....................                
....................                if( kt_the(UID))
0B1C:  CLRF   75
0B1D:  MOVLW  62
0B1E:  MOVWF  74
0B1F:  BCF    0A.3
0B20:  CALL   7A5
0B21:  BSF    0A.3
0B22:  MOVF   78,F
0B23:  BTFSC  03.2
0B24:  GOTO   350
....................                { 
....................                      bipbip(3,3);
0B25:  MOVLW  03
0B26:  MOVWF  7D
0B27:  MOVWF  7E
0B28:  CALL   000
....................                      printf(LCD_PUTC, "\f the hop le");
0B29:  MOVLW  B4
0B2A:  BSF    03.6
0B2B:  MOVWF  0D
0B2C:  MOVLW  00
0B2D:  MOVWF  0F
0B2E:  BCF    0A.3
0B2F:  BCF    03.6
0B30:  CALL   56A
0B31:  BSF    0A.3
....................                      lcd_gotoxy(0,2);
0B32:  BSF    03.5
0B33:  CLRF   24
0B34:  MOVLW  02
0B35:  MOVWF  25
0B36:  BCF    0A.3
0B37:  BCF    03.5
0B38:  CALL   357
0B39:  BSF    0A.3
....................                      printf(LCD_PUTC, "xin moi vao");
0B3A:  MOVLW  BB
0B3B:  BSF    03.6
0B3C:  MOVWF  0D
0B3D:  MOVLW  00
0B3E:  MOVWF  0F
0B3F:  BCF    0A.3
0B40:  BCF    03.6
0B41:  CALL   56A
0B42:  BSF    0A.3
....................                      delay_ms(1000);
0B43:  MOVLW  04
0B44:  MOVWF  74
0B45:  MOVLW  FA
0B46:  BSF    03.5
0B47:  MOVWF  24
0B48:  BCF    0A.3
0B49:  BCF    03.5
0B4A:  CALL   292
0B4B:  BSF    0A.3
0B4C:  DECFSZ 74,F
0B4D:  GOTO   345
....................                      door = 1;
0B4E:  BSF    56.0
....................                }
0B4F:  GOTO   387
....................                else
....................                {
....................                   lcd_putc('\f');
0B50:  MOVLW  0C
0B51:  BSF    03.5
0B52:  MOVWF  23
0B53:  BCF    0A.3
0B54:  BCF    03.5
0B55:  CALL   36B
0B56:  BSF    0A.3
....................                   lcd_gotoxy(0, 1);
0B57:  BSF    03.5
0B58:  CLRF   24
0B59:  MOVLW  01
0B5A:  MOVWF  25
0B5B:  BCF    0A.3
0B5C:  BCF    03.5
0B5D:  CALL   357
0B5E:  BSF    0A.3
....................                   printf (LCD_PUTC, "SAI THE");
0B5F:  MOVLW  C1
0B60:  BSF    03.6
0B61:  MOVWF  0D
0B62:  MOVLW  00
0B63:  MOVWF  0F
0B64:  BCF    0A.3
0B65:  BCF    03.6
0B66:  CALL   56A
0B67:  BSF    0A.3
....................                   lcd_gotoxy(4, 2);
0B68:  MOVLW  04
0B69:  BSF    03.5
0B6A:  MOVWF  24
0B6B:  MOVLW  02
0B6C:  MOVWF  25
0B6D:  BCF    0A.3
0B6E:  BCF    03.5
0B6F:  CALL   357
0B70:  BSF    0A.3
....................                   printf (LCD_PUTC, "WARNING!!!");
0B71:  MOVLW  C5
0B72:  BSF    03.6
0B73:  MOVWF  0D
0B74:  MOVLW  00
0B75:  MOVWF  0F
0B76:  BCF    0A.3
0B77:  BCF    03.6
0B78:  CALL   56A
0B79:  BSF    0A.3
....................                   bipbip(20,10);
0B7A:  MOVLW  14
0B7B:  MOVWF  7D
0B7C:  MOVLW  0A
0B7D:  MOVWF  7E
0B7E:  CALL   000
....................                   lcd_putc('\f');
0B7F:  MOVLW  0C
0B80:  BSF    03.5
0B81:  MOVWF  23
0B82:  BCF    0A.3
0B83:  BCF    03.5
0B84:  CALL   36B
0B85:  BSF    0A.3
....................                   door = 0;
0B86:  BCF    56.0
....................                } 
....................             }
....................         }
....................         
....................    if (m =='1')
0B87:  MOVF   61,W
0B88:  SUBLW  31
0B89:  BTFSS  03.2
0B8A:  GOTO   3D9
....................    {
....................    lcd_gotoxy(1,2);
0B8B:  MOVLW  01
0B8C:  BSF    03.5
0B8D:  MOVWF  24
0B8E:  MOVLW  02
0B8F:  MOVWF  25
0B90:  BCF    0A.3
0B91:  BCF    03.5
0B92:  CALL   357
0B93:  BSF    0A.3
....................    lcd_putc(str[0]); lcd_putc(str[1]); lcd_putc(str[2]); lcd_putc(str[3]);
0B94:  MOVF   69,W
0B95:  BSF    03.5
0B96:  MOVWF  23
0B97:  BCF    0A.3
0B98:  BCF    03.5
0B99:  CALL   36B
0B9A:  BSF    0A.3
0B9B:  MOVF   6A,W
0B9C:  BSF    03.5
0B9D:  MOVWF  23
0B9E:  BCF    0A.3
0B9F:  BCF    03.5
0BA0:  CALL   36B
0BA1:  BSF    0A.3
0BA2:  MOVF   6B,W
0BA3:  BSF    03.5
0BA4:  MOVWF  23
0BA5:  BCF    0A.3
0BA6:  BCF    03.5
0BA7:  CALL   36B
0BA8:  BSF    0A.3
0BA9:  MOVF   6C,W
0BAA:  BSF    03.5
0BAB:  MOVWF  23
0BAC:  BCF    0A.3
0BAD:  BCF    03.5
0BAE:  CALL   36B
0BAF:  BSF    0A.3
....................    mk1=read_eeprom(1);
0BB0:  MOVLW  01
0BB1:  BSF    03.6
0BB2:  MOVWF  0D
0BB3:  BSF    03.5
0BB4:  BCF    0C.7
0BB5:  BSF    0C.0
0BB6:  BCF    03.5
0BB7:  MOVF   0C,W
0BB8:  BCF    03.6
0BB9:  MOVWF  57
....................    mk2=read_eeprom(2);
0BBA:  MOVLW  02
0BBB:  BSF    03.6
0BBC:  MOVWF  0D
0BBD:  BSF    03.5
0BBE:  BCF    0C.7
0BBF:  BSF    0C.0
0BC0:  BCF    03.5
0BC1:  MOVF   0C,W
0BC2:  BCF    03.6
0BC3:  MOVWF  58
....................    mk3=read_eeprom(3);
0BC4:  MOVLW  03
0BC5:  BSF    03.6
0BC6:  MOVWF  0D
0BC7:  BSF    03.5
0BC8:  BCF    0C.7
0BC9:  BSF    0C.0
0BCA:  BCF    03.5
0BCB:  MOVF   0C,W
0BCC:  BCF    03.6
0BCD:  MOVWF  59
....................    mk4=read_eeprom(4);
0BCE:  MOVLW  04
0BCF:  BSF    03.6
0BD0:  MOVWF  0D
0BD1:  BSF    03.5
0BD2:  BCF    0C.7
0BD3:  BSF    0C.0
0BD4:  BCF    03.5
0BD5:  MOVF   0C,W
0BD6:  BCF    03.6
0BD7:  MOVWF  5A
....................    kt_pass();
0BD8:  CALL   02F
....................    }
....................    if (m=='2'&&str[1]!='F')
0BD9:  MOVF   61,W
0BDA:  SUBLW  32
0BDB:  BTFSS  03.2
0BDC:  GOTO   3E1
0BDD:  MOVF   6A,W
0BDE:  SUBLW  46
0BDF:  BTFSS  03.2
....................    {
....................    //!   otp();
....................    //!
....................    //!    lcd_gotoxy(1,2);
....................    //!    lcd_putc(mk1); lcd_putc(mk1); lcd_putc(mk1); lcd_putc(mk1);
....................       
....................       kt_pass();
0BE0:  CALL   02F
....................    }
....................    }
....................    while ( door!= 1 );
0BE1:  BTFSS  56.0
0BE2:  GOTO   206
....................    
....................    output_high(PIN_D3);
0BE3:  BSF    03.5
0BE4:  BCF    08.3
0BE5:  BCF    03.5
0BE6:  BSF    08.3
....................      
....................    lcd_putc("\f");
0BE7:  MOVLW  CB
0BE8:  BSF    03.6
0BE9:  MOVWF  0D
0BEA:  MOVLW  00
0BEB:  MOVWF  0F
0BEC:  BCF    0A.3
0BED:  BCF    03.6
0BEE:  CALL   56A
0BEF:  BSF    0A.3
....................    delay_ms(2000);
0BF0:  MOVLW  08
0BF1:  MOVWF  74
0BF2:  MOVLW  FA
0BF3:  BSF    03.5
0BF4:  MOVWF  24
0BF5:  BCF    0A.3
0BF6:  BCF    03.5
0BF7:  CALL   292
0BF8:  BSF    0A.3
0BF9:  DECFSZ 74,F
0BFA:  GOTO   3F2
....................    output_low(PIN_D3);
0BFB:  BSF    03.5
0BFC:  BCF    08.3
0BFD:  BCF    03.5
0BFE:  BCF    08.3
....................    }
.................... while(input(PIN_A5)==0);
0BFF:  BSF    03.5
0C00:  BSF    05.5
0C01:  BCF    03.5
0C02:  BTFSS  05.5
0C03:  GOTO   201
.................... //Gui xac nhan///
.................... printf("OPEN");
0C04:  MOVLW  CC
0C05:  BSF    03.6
0C06:  MOVWF  0D
0C07:  MOVLW  00
0C08:  MOVWF  0F
0C09:  BCF    0A.3
0C0A:  BCF    03.6
0C0B:  CALL   3A5
0C0C:  BSF    0A.3
.................... //Bat dau dem thoi gian//
.................... bdt = 0;
0C0D:  CLRF   55
.................... do
.................... {
.................... bdt = 0;
0C0E:  CLRF   55
.................... do
.................... {  
....................    getkey();
0C0F:  BCF    0A.3
0C10:  CALL   3F7
0C11:  BSF    0A.3
....................    m=getkey();
0C12:  BCF    0A.3
0C13:  CALL   3F7
0C14:  BSF    0A.3
0C15:  MOVF   78,W
0C16:  MOVWF  61
.................... //!   lcd_gotoxy(1,1);
.................... //!   lcd_putc("1. DOI PASS");
....................    lcd_gotoxy(1,2);
0C17:  MOVLW  01
0C18:  BSF    03.5
0C19:  MOVWF  24
0C1A:  MOVLW  02
0C1B:  MOVWF  25
0C1C:  BCF    0A.3
0C1D:  BCF    03.5
0C1E:  CALL   357
0C1F:  BSF    0A.3
....................    lcd_putc("2. KHOA   3.RFID");
0C20:  MOVLW  CF
0C21:  BSF    03.6
0C22:  MOVWF  0D
0C23:  MOVLW  00
0C24:  MOVWF  0F
0C25:  BCF    0A.3
0C26:  BCF    03.6
0C27:  CALL   56A
0C28:  BSF    0A.3
....................    //ACS712//
.................... //!    delay_us(100);
.................... //!      adc_value = read_adc();
.................... //!      if( adc_value<495)
.................... //!      {
.................... //!         printf("OPEN");
.................... //!      }
.................... //!    lcd_gotoxy(2,1);
.................... //!    printf(lcd_putc, "%.2f  ",  (float)adc_value);
.................... //!    delay_ms(100);
....................    //
....................    if(bdt>100)
0C29:  MOVF   55,W
0C2A:  SUBLW  64
0C2B:  BTFSC  03.0
0C2C:  GOTO   44B
....................    {
....................       if (input(PIN_A5)==1)
0C2D:  BSF    03.5
0C2E:  BSF    05.5
0C2F:  BCF    03.5
0C30:  BTFSS  05.5
0C31:  GOTO   44A
....................       {
....................          bipbip(50,10);
0C32:  MOVLW  32
0C33:  MOVWF  7D
0C34:  MOVLW  0A
0C35:  MOVWF  7E
0C36:  CALL   000
....................          bdt=0;
0C37:  CLRF   55
....................          lcd_gotoxy(1,1);
0C38:  MOVLW  01
0C39:  BSF    03.5
0C3A:  MOVWF  24
0C3B:  MOVWF  25
0C3C:  BCF    0A.3
0C3D:  BCF    03.5
0C3E:  CALL   357
0C3F:  BSF    0A.3
....................          lcd_putc("CUA DANG MO");
0C40:  MOVLW  D8
0C41:  BSF    03.6
0C42:  MOVWF  0D
0C43:  MOVLW  00
0C44:  MOVWF  0F
0C45:  BCF    0A.3
0C46:  BCF    03.6
0C47:  CALL   56A
0C48:  BSF    0A.3
....................       }
0C49:  GOTO   44B
....................       else
....................       {
....................          door = 0;
0C4A:  BCF    56.0
....................       }
....................    }
.................... }
.................... while (m!='1'&& m!='2' && m!='3' && door==1);
0C4B:  MOVF   61,W
0C4C:  SUBLW  31
0C4D:  BTFSC  03.2
0C4E:  GOTO   459
0C4F:  MOVF   61,W
0C50:  SUBLW  32
0C51:  BTFSC  03.2
0C52:  GOTO   459
0C53:  MOVF   61,W
0C54:  SUBLW  33
0C55:  BTFSC  03.2
0C56:  GOTO   459
0C57:  BTFSC  56.0
0C58:  GOTO   40F
....................  
.................... 
.................... if (m=='1')
0C59:  MOVF   61,W
0C5A:  SUBLW  31
0C5B:  BTFSS  03.2
0C5C:  GOTO   559
.................... {
....................    lcd_putc('\f');
0C5D:  MOVLW  0C
0C5E:  BSF    03.5
0C5F:  MOVWF  23
0C60:  BCF    0A.3
0C61:  BCF    03.5
0C62:  CALL   36B
0C63:  BSF    0A.3
....................    lcd_putc("Nhap mat khau");
0C64:  MOVLW  DE
0C65:  BSF    03.6
0C66:  MOVWF  0D
0C67:  MOVLW  00
0C68:  MOVWF  0F
0C69:  BCF    0A.3
0C6A:  BCF    03.6
0C6B:  CALL   56A
0C6C:  BSF    0A.3
....................    delay_ms(1000);
0C6D:  MOVLW  04
0C6E:  MOVWF  74
0C6F:  MOVLW  FA
0C70:  BSF    03.5
0C71:  MOVWF  24
0C72:  BCF    0A.3
0C73:  BCF    03.5
0C74:  CALL   292
0C75:  BSF    0A.3
0C76:  DECFSZ 74,F
0C77:  GOTO   46F
....................    lcd_putc('\f');
0C78:  MOVLW  0C
0C79:  BSF    03.5
0C7A:  MOVWF  23
0C7B:  BCF    0A.3
0C7C:  BCF    03.5
0C7D:  CALL   36B
0C7E:  BSF    0A.3
.................... do
.................... {
....................    getkey();
0C7F:  BCF    0A.3
0C80:  CALL   3F7
0C81:  BSF    0A.3
....................    a=getkey();
0C82:  BCF    0A.3
0C83:  CALL   3F7
0C84:  BSF    0A.3
0C85:  MOVF   78,W
0C86:  MOVWF  5D
.................... }
.................... while (a=='n');
0C87:  MOVF   5D,W
0C88:  SUBLW  6E
0C89:  BTFSC  03.2
0C8A:  GOTO   47F
....................    lcd_putc(a);
0C8B:  MOVF   5D,W
0C8C:  BSF    03.5
0C8D:  MOVWF  23
0C8E:  BCF    0A.3
0C8F:  BCF    03.5
0C90:  CALL   36B
0C91:  BSF    0A.3
.................... write_eeprom(1,a);
0C92:  MOVF   0B,W
0C93:  MOVWF  77
0C94:  BCF    0B.7
0C95:  MOVLW  01
0C96:  BSF    03.6
0C97:  MOVWF  0D
0C98:  BCF    03.6
0C99:  MOVF   5D,W
0C9A:  BSF    03.6
0C9B:  MOVWF  0C
0C9C:  BSF    03.5
0C9D:  BCF    0C.7
0C9E:  BSF    0C.2
0C9F:  MOVLW  55
0CA0:  MOVWF  0D
0CA1:  MOVLW  AA
0CA2:  MOVWF  0D
0CA3:  BSF    0C.1
0CA4:  BTFSC  0C.1
0CA5:  GOTO   4A4
0CA6:  BCF    0C.2
0CA7:  MOVF   77,W
0CA8:  BCF    03.5
0CA9:  BCF    03.6
0CAA:  IORWF  0B,F
.................... do
.................... {
....................    getkey();
0CAB:  BCF    0A.3
0CAC:  CALL   3F7
0CAD:  BSF    0A.3
....................    b=getkey();
0CAE:  BCF    0A.3
0CAF:  CALL   3F7
0CB0:  BSF    0A.3
0CB1:  MOVF   78,W
0CB2:  MOVWF  5E
.................... }
.................... while (b=='n');
0CB3:  MOVF   5E,W
0CB4:  SUBLW  6E
0CB5:  BTFSC  03.2
0CB6:  GOTO   4AB
....................    lcd_putc(b);
0CB7:  MOVF   5E,W
0CB8:  BSF    03.5
0CB9:  MOVWF  23
0CBA:  BCF    0A.3
0CBB:  BCF    03.5
0CBC:  CALL   36B
0CBD:  BSF    0A.3
.................... write_eeprom(2,b);
0CBE:  MOVF   0B,W
0CBF:  MOVWF  77
0CC0:  BCF    0B.7
0CC1:  MOVLW  02
0CC2:  BSF    03.6
0CC3:  MOVWF  0D
0CC4:  BCF    03.6
0CC5:  MOVF   5E,W
0CC6:  BSF    03.6
0CC7:  MOVWF  0C
0CC8:  BSF    03.5
0CC9:  BCF    0C.7
0CCA:  BSF    0C.2
0CCB:  MOVLW  55
0CCC:  MOVWF  0D
0CCD:  MOVLW  AA
0CCE:  MOVWF  0D
0CCF:  BSF    0C.1
0CD0:  BTFSC  0C.1
0CD1:  GOTO   4D0
0CD2:  BCF    0C.2
0CD3:  MOVF   77,W
0CD4:  BCF    03.5
0CD5:  BCF    03.6
0CD6:  IORWF  0B,F
.................... do
.................... {
....................    getkey();
0CD7:  BCF    0A.3
0CD8:  CALL   3F7
0CD9:  BSF    0A.3
....................    c=getkey();
0CDA:  BCF    0A.3
0CDB:  CALL   3F7
0CDC:  BSF    0A.3
0CDD:  MOVF   78,W
0CDE:  MOVWF  5F
.................... }
.................... while (c=='n');
0CDF:  MOVF   5F,W
0CE0:  SUBLW  6E
0CE1:  BTFSC  03.2
0CE2:  GOTO   4D7
....................    lcd_putc(c);
0CE3:  MOVF   5F,W
0CE4:  BSF    03.5
0CE5:  MOVWF  23
0CE6:  BCF    0A.3
0CE7:  BCF    03.5
0CE8:  CALL   36B
0CE9:  BSF    0A.3
.................... write_eeprom(3,c);
0CEA:  MOVF   0B,W
0CEB:  MOVWF  77
0CEC:  BCF    0B.7
0CED:  MOVLW  03
0CEE:  BSF    03.6
0CEF:  MOVWF  0D
0CF0:  BCF    03.6
0CF1:  MOVF   5F,W
0CF2:  BSF    03.6
0CF3:  MOVWF  0C
0CF4:  BSF    03.5
0CF5:  BCF    0C.7
0CF6:  BSF    0C.2
0CF7:  MOVLW  55
0CF8:  MOVWF  0D
0CF9:  MOVLW  AA
0CFA:  MOVWF  0D
0CFB:  BSF    0C.1
0CFC:  BTFSC  0C.1
0CFD:  GOTO   4FC
0CFE:  BCF    0C.2
0CFF:  MOVF   77,W
0D00:  BCF    03.5
0D01:  BCF    03.6
0D02:  IORWF  0B,F
.................... do
.................... {
....................    getkey();
0D03:  BCF    0A.3
0D04:  CALL   3F7
0D05:  BSF    0A.3
....................    d=getkey();
0D06:  BCF    0A.3
0D07:  CALL   3F7
0D08:  BSF    0A.3
0D09:  MOVF   78,W
0D0A:  MOVWF  60
.................... }
.................... while (d=='n');
0D0B:  MOVF   60,W
0D0C:  SUBLW  6E
0D0D:  BTFSC  03.2
0D0E:  GOTO   503
....................    lcd_putc(d);
0D0F:  MOVF   60,W
0D10:  BSF    03.5
0D11:  MOVWF  23
0D12:  BCF    0A.3
0D13:  BCF    03.5
0D14:  CALL   36B
0D15:  BSF    0A.3
....................    write_eeprom(4,d);
0D16:  MOVF   0B,W
0D17:  MOVWF  77
0D18:  BCF    0B.7
0D19:  MOVLW  04
0D1A:  BSF    03.6
0D1B:  MOVWF  0D
0D1C:  BCF    03.6
0D1D:  MOVF   60,W
0D1E:  BSF    03.6
0D1F:  MOVWF  0C
0D20:  BSF    03.5
0D21:  BCF    0C.7
0D22:  BSF    0C.2
0D23:  MOVLW  55
0D24:  MOVWF  0D
0D25:  MOVLW  AA
0D26:  MOVWF  0D
0D27:  BSF    0C.1
0D28:  BTFSC  0C.1
0D29:  GOTO   528
0D2A:  BCF    0C.2
0D2B:  MOVF   77,W
0D2C:  BCF    03.5
0D2D:  BCF    03.6
0D2E:  IORWF  0B,F
....................    delay_ms(1000);
0D2F:  MOVLW  04
0D30:  MOVWF  74
0D31:  MOVLW  FA
0D32:  BSF    03.5
0D33:  MOVWF  24
0D34:  BCF    0A.3
0D35:  BCF    03.5
0D36:  CALL   292
0D37:  BSF    0A.3
0D38:  DECFSZ 74,F
0D39:  GOTO   531
....................    lcd_putc('\f');
0D3A:  MOVLW  0C
0D3B:  BSF    03.5
0D3C:  MOVWF  23
0D3D:  BCF    0A.3
0D3E:  BCF    03.5
0D3F:  CALL   36B
0D40:  BSF    0A.3
....................    lcd_putc("Press 1 to block");
0D41:  MOVLW  E5
0D42:  BSF    03.6
0D43:  MOVWF  0D
0D44:  MOVLW  00
0D45:  MOVWF  0F
0D46:  BCF    0A.3
0D47:  BCF    03.6
0D48:  CALL   56A
0D49:  BSF    0A.3
.................... do
.................... {
....................    getkey();
0D4A:  BCF    0A.3
0D4B:  CALL   3F7
0D4C:  BSF    0A.3
....................    m=getkey();
0D4D:  BCF    0A.3
0D4E:  CALL   3F7
0D4F:  BSF    0A.3
0D50:  MOVF   78,W
0D51:  MOVWF  61
.................... }
.................... while (m!='1');
0D52:  MOVF   61,W
0D53:  SUBLW  31
0D54:  BTFSS  03.2
0D55:  GOTO   54A
.................... 
....................    bdt=50;
0D56:  MOVLW  32
0D57:  MOVWF  55
....................    
.................... }
0D58:  GOTO   633
.................... 
....................  else if (m=='3')
0D59:  MOVF   61,W
0D5A:  SUBLW  33
0D5B:  BTFSS  03.2
0D5C:  GOTO   633
....................  {
....................    lcd_putc("\f1. Them the");
0D5D:  MOVLW  EE
0D5E:  BSF    03.6
0D5F:  MOVWF  0D
0D60:  MOVLW  00
0D61:  MOVWF  0F
0D62:  BCF    0A.3
0D63:  BCF    03.6
0D64:  CALL   56A
0D65:  BSF    0A.3
....................    lcd_gotoxy(1,2);
0D66:  MOVLW  01
0D67:  BSF    03.5
0D68:  MOVWF  24
0D69:  MOVLW  02
0D6A:  MOVWF  25
0D6B:  BCF    0A.3
0D6C:  BCF    03.5
0D6D:  CALL   357
0D6E:  BSF    0A.3
....................    lcd_putc("2. Xoa the");
0D6F:  MOVLW  F5
0D70:  BSF    03.6
0D71:  MOVWF  0D
0D72:  MOVLW  00
0D73:  MOVWF  0F
0D74:  BCF    0A.3
0D75:  BCF    03.6
0D76:  CALL   56A
0D77:  BSF    0A.3
....................    do
....................    {
....................       getkey();
0D78:  BCF    0A.3
0D79:  CALL   3F7
0D7A:  BSF    0A.3
....................       m=getkey();
0D7B:  BCF    0A.3
0D7C:  CALL   3F7
0D7D:  BSF    0A.3
0D7E:  MOVF   78,W
0D7F:  MOVWF  61
....................    }  
....................    while (m!='1' && m!='2');
0D80:  MOVF   61,W
0D81:  SUBLW  31
0D82:  BTFSC  03.2
0D83:  GOTO   588
0D84:  MOVF   61,W
0D85:  SUBLW  32
0D86:  BTFSS  03.2
0D87:  GOTO   578
....................    if(m=='1')
0D88:  MOVF   61,W
0D89:  SUBLW  31
0D8A:  BTFSS  03.2
0D8B:  GOTO   5D8
....................    {
....................       lcd_putc("\f Quet the moi");
0D8C:  MOVLW  FB
0D8D:  BSF    03.6
0D8E:  MOVWF  0D
0D8F:  MOVLW  00
0D90:  MOVWF  0F
0D91:  BCF    0A.3
0D92:  BCF    03.6
0D93:  CALL   56A
0D94:  BSF    0A.3
....................       do{}
....................       while (MFRC522_isCard (&TagType)!=1); //Check any card
0D95:  CLRF   75
0D96:  MOVLW  68
0D97:  MOVWF  74
0D98:  BCF    0A.3
0D99:  CALL   6FD
0D9A:  BSF    0A.3
0D9B:  DECFSZ 78,W
0D9C:  GOTO   595
....................       MFRC522_ReadCardSerial (&UID);
0D9D:  CLRF   75
0D9E:  MOVLW  62
0D9F:  MOVWF  74
0DA0:  BCF    0A.3
0DA1:  CALL   73A
0DA2:  BSF    0A.3
....................       bipbip(10,10);
0DA3:  MOVLW  0A
0DA4:  MOVWF  7D
0DA5:  MOVWF  7E
0DA6:  CALL   000
....................       if (kt_the(UID))
0DA7:  CLRF   75
0DA8:  MOVLW  62
0DA9:  MOVWF  74
0DAA:  BCF    0A.3
0DAB:  CALL   7A5
0DAC:  BSF    0A.3
0DAD:  MOVF   78,F
0DAE:  BTFSC  03.2
0DAF:  GOTO   5C2
....................       {
....................          lcd_gotoxy(1,1);
0DB0:  MOVLW  01
0DB1:  BSF    03.5
0DB2:  MOVWF  24
0DB3:  MOVWF  25
0DB4:  BCF    0A.3
0DB5:  BCF    03.5
0DB6:  CALL   357
0DB7:  BSF    0A.3
....................          lcd_putc("\f The da them");
0DB8:  MOVLW  03
0DB9:  BSF    03.6
0DBA:  MOVWF  0D
0DBB:  MOVLW  01
0DBC:  MOVWF  0F
0DBD:  BCF    0A.3
0DBE:  BCF    03.6
0DBF:  CALL   56A
0DC0:  BSF    0A.3
....................       }
0DC1:  GOTO   5D7
....................       else
....................       {
....................          them_the(UID);
0DC2:  CLRF   75
0DC3:  MOVLW  62
0DC4:  MOVWF  74
0DC5:  GOTO   102
....................          lcd_gotoxy(1,1);
0DC6:  MOVLW  01
0DC7:  BSF    03.5
0DC8:  MOVWF  24
0DC9:  MOVWF  25
0DCA:  BCF    0A.3
0DCB:  BCF    03.5
0DCC:  CALL   357
0DCD:  BSF    0A.3
....................          lcd_putc("\f XONG");   
0DCE:  MOVLW  0A
0DCF:  BSF    03.6
0DD0:  MOVWF  0D
0DD1:  MOVLW  01
0DD2:  MOVWF  0F
0DD3:  BCF    0A.3
0DD4:  BCF    03.6
0DD5:  CALL   56A
0DD6:  BSF    0A.3
....................       }
....................    }
0DD7:  GOTO   613
....................    else 
....................    {  
....................       lcd_putc("\f Quet the can xoa");
0DD8:  MOVLW  0E
0DD9:  BSF    03.6
0DDA:  MOVWF  0D
0DDB:  MOVLW  01
0DDC:  MOVWF  0F
0DDD:  BCF    0A.3
0DDE:  BCF    03.6
0DDF:  CALL   56A
0DE0:  BSF    0A.3
....................       do{}
....................       while (MFRC522_isCard (&TagType)!=1); //Check any card
0DE1:  CLRF   75
0DE2:  MOVLW  68
0DE3:  MOVWF  74
0DE4:  BCF    0A.3
0DE5:  CALL   6FD
0DE6:  BSF    0A.3
0DE7:  DECFSZ 78,W
0DE8:  GOTO   5E1
....................       MFRC522_ReadCardSerial (&UID);
0DE9:  CLRF   75
0DEA:  MOVLW  62
0DEB:  MOVWF  74
0DEC:  BCF    0A.3
0DED:  CALL   73A
0DEE:  BSF    0A.3
....................       bipbip(10,10);
0DEF:  MOVLW  0A
0DF0:  MOVWF  7D
0DF1:  MOVWF  7E
0DF2:  CALL   000
....................       if (kt_the(UID))
0DF3:  CLRF   75
0DF4:  MOVLW  62
0DF5:  MOVWF  74
0DF6:  BCF    0A.3
0DF7:  CALL   7A5
0DF8:  BSF    0A.3
0DF9:  MOVF   78,F
0DFA:  BTFSC  03.2
0DFB:  GOTO   60A
....................       {
....................          xoa_the(UID);
0DFC:  CLRF   75
0DFD:  MOVLW  62
0DFE:  MOVWF  74
0DFF:  GOTO   14E
....................          lcd_putc("\f Da xoa");
0E00:  MOVLW  18
0E01:  BSF    03.6
0E02:  MOVWF  0D
0E03:  MOVLW  01
0E04:  MOVWF  0F
0E05:  BCF    0A.3
0E06:  BCF    03.6
0E07:  CALL   56A
0E08:  BSF    0A.3
....................       }
0E09:  GOTO   613
....................       else
....................          lcd_putc("\fKhong co the nay");
0E0A:  MOVLW  1D
0E0B:  BSF    03.6
0E0C:  MOVWF  0D
0E0D:  MOVLW  01
0E0E:  MOVWF  0F
0E0F:  BCF    0A.3
0E10:  BCF    03.6
0E11:  CALL   56A
0E12:  BSF    0A.3
....................    }
....................    lcd_gotoxy(1,2);
0E13:  MOVLW  01
0E14:  BSF    03.5
0E15:  MOVWF  24
0E16:  MOVLW  02
0E17:  MOVWF  25
0E18:  BCF    0A.3
0E19:  BCF    03.5
0E1A:  CALL   357
0E1B:  BSF    0A.3
....................    lcd_putc("Press 1 to block");
0E1C:  MOVLW  26
0E1D:  BSF    03.6
0E1E:  MOVWF  0D
0E1F:  MOVLW  01
0E20:  MOVWF  0F
0E21:  BCF    0A.3
0E22:  BCF    03.6
0E23:  CALL   56A
0E24:  BSF    0A.3
.................... do
.................... {
....................    getkey();
0E25:  BCF    0A.3
0E26:  CALL   3F7
0E27:  BSF    0A.3
....................    m=getkey();
0E28:  BCF    0A.3
0E29:  CALL   3F7
0E2A:  BSF    0A.3
0E2B:  MOVF   78,W
0E2C:  MOVWF  61
.................... }
.................... while (m!='1');
0E2D:  MOVF   61,W
0E2E:  SUBLW  31
0E2F:  BTFSS  03.2
0E30:  GOTO   625
....................  bdt = 50;
0E31:  MOVLW  32
0E32:  MOVWF  55
....................  }
....................  
.................... }
....................     while(door==1);
0E33:  BTFSC  56.0
0E34:  GOTO   40E
0E35:  GOTO   1EC
....................     
....................       //TODO: User Code
....................    }
.................... 
.................... }
.................... 
0E36:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
